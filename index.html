<!DOCTYPE html>
<html lang="en">

<head>
    <title>A Tour of C#</title>
    <link rel="stylesheet" type="text/css" href="./CSS/index.css">
    <meta name="description" content="A Tour of C# - Technical Doocumentation Page">
    <meta name="author" content="David Price">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8" />
</head>

<body>

    <nav class="navbar">
        <header>
            <h1>A Tour of C#</h1>
        </header>
        <ul>
            <li><a class="nav-link" href="#introduction">Introduction</a>
                <ul>
                    <li><a class="nav-link" href="#hello-world">Hello World</a></li>
                    <li><a class="nav-link" href="#types-and-variables">Types & Variables</a></li>
                    <li><a class="nav-link" href="#program-structure">Program Structure</a></li>
                </ul>
            </li>
            <li><a class="nav-link" href="#types">Types</a>
                <ul>
                    <li><a class="nav-link" href="#classes-and-objects">Classes and Objects</a></li>
                    <li><a class="nav-link" href="#type-parameters">Type Parameters</a></li>
                    <li><a class="nav-link" href="#base-classes">Base Classes</a></li>
                    <li><a class="nav-link" href="#structs">Structs</a></li>
                    <li><a class="nav-link" href="#interfaces">Interfaces</a></li>
                    <li><a class="nav-link" href="#enums">Enums</a></li>
                    <li><a class="nav-link" href="#nullable-types">Nullable Types</a></li>
                    <li><a class="nav-link" href="#tuples">Tuples</a></li>
                </ul>
            </li>
            <li><a class="nav-link" href="#program-building-blocks">Program Building Blocks</a>
                <ul>
                    <li><a class="nav-link" href="#members">Members</a></li>
                    <li><a class="nav-link" href="#accessibility">Accessibility</a></li>
                    <li><a class="nav-link" href="#fields">Fields</a></li>
                    <li><a class="nav-link" href="#methods">Methods</a></li>
                    <li><a class="nav-link" href="#parameters">Parameters</a></li>
                    <li><a class="nav-link" href="#method-body-and-local-variables">Method Body and Local Variables</a>
                    </li>
                    <li><a class="nav-link" href="#static-and-instance-methods">Static and Instance Methods</a></li>
                    <li><a class="nav-link" href="#virtual-override-and-abstract-methods">Virtual, Override and Abstract
                            Methods</a></li>
                    <li><a class="nav-link" href="#method-overloading">Method Overloading</a></li>
                    <li><a class="nav-link" href="#other-function-members">Other Function Members</a></li>
                    <li><a class="nav-link" href="#constructors">Constructors</a></li>
                    <li><a class="nav-link" href="#properties">Properties</a></li>
                    <li><a class="nav-link" href="#indexers">Indexers</a></li>
                    <li><a class="nav-link" href="#events">Events</a></li>
                    <li><a class="nav-link" href="#operators">Operators</a></li>
                    <li><a class="nav-link" href="#finalizers">Finalizers</a></li>
                    <li><a class="nav-link" href="#expressions">Expressions</a></li>
                    <li><a class="nav-link" href="#statements">Statements</a></li>
                </ul>
            </li>
            <li><a class="nav-link" href="#major-language-areas">Major Language Areas</a>
                <ul>
                    <li><a class="nav-link" href="#arrays-collections-and-linq">Arrays, Collections and LINQ</a></li>
                    <li><a class="nav-link" href="#arrays">Arrays</a></li>
                    <li><a class="nav-link" href="#string-interpolation">String Interpolation</a></li>
                    <li><a class="nav-link" href="#pattern-matching">Pattern Matching</a></li>
                    <li><a class="nav-link" href="#delegates-and-llambda-expressions">Delegates and Llambda
                            Expressions</a></li>
                    <li><a class="nav-link" href="#async-await">Async / Await</a></li>
                    <li><a class="nav-link" href="#attributes">Attributes</a></li>
                </ul>
            </li>
        </ul>
    </nav>

    <main>
        <section id="introduction">
            <header>
                <h2>A tour of the C# Language</h2>
            </header>
            <article>
                <p>C# (pronounced "See Sharp") is a modern, object-oriented, and type-safe programming language. C# has
                    its roots in the C family of languages and will be immediately familiar to C, C++, Java, and
                    JavaScript programmers. This tour provides an overview of the major components of the language in C#
                    8 and earlier. If you want to explore the language through interactive examples, try the
                    <a href="https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/intro-to-csharp/">introduction to
                        C#</a> tutorials.</p>
                <p>C# is an object-oriented, <strong>component-oriented</strong> programming language. C# provides
                    language constructs to
                    directly support these concepts, making C# a natural language in which to create and use software
                    components. Since its origin, C# has added features to support new workloads and emerging software
                    design practices.</p>
                <p>Several C# features aid in the construction of robust and durable applications. <a
                        href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/">Garbage
                        collection</a>
                    automatically reclaims memory occupied by unreachable unused objects. <a
                        href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/exceptions/">Exception
                        handling</a> provides a
                    structured and extensible approach to error detection and recovery. <a
                        href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/lambda-expressions">Lambda
                        expressions</a> support
                    functional programming techniques. <a
                        href="https://docs.microsoft.com/en-us/dotnet/csharp/linq/">Query syntax</a> creates a common
                    pattern for working with data from
                    any source. Language support for <a
                        href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/">asynchronous
                        operations</a> provides syntax for building distributed
                    systems. <a href="https://docs.microsoft.com/en-us/dotnet/csharp/pattern-matching">Pattern
                        matching</a> provides syntax to easily separate data from algorithms in modern
                    distributed systems. C# has a <a
                        href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/">unified type
                        system</a>. All C# types, including primitive types such as
                    <code>int</code> and <code>double</code>, inherit from a single root <code>object</code> type. All
                    types share a set of common operations.
                    Values of any type can be stored, transported, and operated upon in a consistent manner.
                    Furthermore, C# supports both user-defined reference types and value types. C# allows dynamic
                    allocation of objects and in-line storage of lightweight structures.</p>
                <p>C# emphasizes <strong>versioning</strong> to ensure programs and libraries can evolve over time in a
                    compatible
                    manner. Aspects of C#'s design that were directly influenced by versioning considerations include
                    the separate <code>virtual</code> and <code>override</code> modifiers, the rules for method overload
                    resolution, and support
                    for explicit interface member declarations.</p>
            </article>

            <section id="hello-world">
                <header>
                    <h3>Hello World</h3>
                </header>
                <article>
                    <p>The "Hello, World" program is traditionally used to introduce a programming language. Here it is
                        in C#:</p>
                    <div>
                        <pre>
                            <code>
<span class="code-keyword">using</span> System;

<span class="code-keyword">class</span> <span class="code-title">Hello</span>
{
    <span class="code-keyword">static void</span> <span class="code-title">Main</span>()
    {
        Console.WriteLine(<span class="code-string">"Hello, world"</span>);
    }
}
                            </code>
                        </pre>
                    </div>
                </article>
            </section>

            <section id="types-and-variables">
                <header>
                    <h3>Types and Variables</h3>
                </header>
                <article>
                    <p>
                        There are two kinds of types in C#: <em>value types</em> and <em>reference types</em>. Variables
                        of value types
                        directly contain their data whereas variables of reference types store references to their data,
                        the latter being known as objects. With reference types, it's possible for two variables to
                        reference the same object and possible for operations on one variable to affect the object
                        referenced by the other variable. With value types, the variables each have their own copy of
                        the data, and it isn't possible for operations on one to affect the other (except for
                        <code>ref</code> and
                        <code>out</code> parameter variables).
                    </p>
                    <p>
                        An <strong><em>identifier</em></strong> is a variable name. An identifier is a sequence of
                        unicode characters without any
                        whitespace. An identifier may be a C# reserved word, if it is prefixed by <code>@</code>. That
                        can be useful
                        when interacting with other languages.
                    </p>
                    <p>
                        C#'s value types are further divided into <em>simple types</em>, <em>enum types</em>, <em>struct
                            types</em>, and <em>nullable
                            value types</em>. C#'s reference types are further divided into <em>class types</em>,
                        <em>interface types</em>, <em>array
                            types</em>, and <em>delegate types</em>.
                    </p>
                    <p>
                        The following outline provides an overview of C#'s type system.
                    </p>
                    <ul>
                        <li><a
                                href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-types">Value
                                types</a></li>
                        <ul>
                            <li><a
                                    href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-types#built-in-value-types">Simple
                                    types</a></li>
                            <ul>
                                <li><a
                                        href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/integral-numeric-types">Signed
                                        integral</a>: <code>sbyte</code>, <code>short</code>, <code>int</code>,
                                    <code>long</code></li>
                                <li><a
                                        href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/integral-numeric-types">Unsigned
                                        integral</a>: <code>byte</code>, <code>ushort</code>, <code>uint</code>,
                                    <code>ulong</code></li>
                                <li><a
                                        href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/character-encoding-introduction">Unicode
                                        characters</a>: <code>char</code>, which represents a UTF-16 code unit</li>
                                <li><a
                                        href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types">IEEE
                                        binary floating-point</a>: <code>float</code>, <code>double</code></li>
                                <li><a
                                        href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types">High-precision
                                        decimal floating-point</a>: <code>decimal</code></li>
                                <li>Boolean: <code>bool</code>, which represents Boolean values - values that are either
                                    <code>true</code> or <code>false</code></li>
                            </ul>
                            <li><a
                                    href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum">Enum
                                    types</a></li>
                            <ul>
                                <li>User-defined types of the form <code>enum E {...}</code>. An <code>enum</code> type
                                    is a distinct type with named constants. Every <code>enum</code> type has an
                                    underlying type, which must be one of the eight intergral types. The set of values
                                    of an <code>enum</code> type is the same as the set of values of the underlying
                                    type.</li>
                            </ul>
                            <li><a
                                    href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/struct">Struct
                                    types</a></li>
                            <ul>
                                <li>User-defined types of the form <code>struct S {...}</code></li>
                            </ul>
                            <li><a
                                    href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-value-types">Nullable
                                    value types</a></li>
                            <ul>
                                <li>Extensions of all other value types with a <code>null</code> value</li>
                            </ul>
                            <li><a href="">Tuple value types</a></li>
                            <ul>
                                <li>User-defined types of the form <code>(T1, T2, ...)</code></li>
                            </ul>
                        </ul>
                        <li><a
                                href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/reference-types">Reference
                                types</a></li>
                        <ul>
                            <li><a
                                    href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/class">Class
                                    types</a></li>
                            <ul>
                                <li>Ultimate base class of all other types: <code>object</code></li>
                                <li><a
                                        href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/character-encoding-introduction">Unicode
                                        strings</a>: <code>string</code>, which represents a sequence of UTF-16 code
                                    units</li>
                                <li>User-defined types of the form <code>class C {...}</code></li>
                            </ul>
                            <li><a
                                    href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface">Interface
                                    types</a></li>
                            <ul>
                                <li>User-defined types of the form <code>interface I {...}</code></li>
                            </ul>
                            <li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/">Array
                                    types</a></li>
                            <ul>
                                <li>Single- and multi-dimensional and jagged, for example, <code>int[]</code>,
                                    <code>int[,]</code>, and <code>int[][]</code></li>
                            </ul>
                            <li><a
                                    href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/reference-types#the-delegate-type">Delegate
                                    types</a></li>
                            <ul>
                                <li>User-defined types of the form <code>delegate int D(...)</code></li>
                            </ul>
                        </ul>
                    </ul>
                    <p>
                        C# programs use <em>type declarations</em> to create new types. A type declaration specifies the name and
                        the members of the new type. Five of C#'s categories of types are user-definable: class types,
                        struct types, interface types, enum types, and delegate types.
                    </p>
                    <ul>
                        <li>A <code>class</code> type defines a data structure that contains data members (fields) and function members (methods, properties, and others). Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</li>
                        <li>A <code>struct</code> type is similar to a class type in that it represents a structure with data members and function members. However, unlike classes, structs are value types and don't typically require heap allocation. Struct types don't support user-specified inheritance, and all struct types implicitly inherit from type <code>object</code>.</li>
                        <li>An <code>interface</code> type defines a contract as a named set of public members. A <code>class</code> or <code>struct</code> that implements an <code>interface</code> must provide implementations of the interface's members. An <code>interface</code> may inherit from multiple base interfaces, and a <code>class</code> or <code>struct</code> may implement multiple interfaces.</li>
                        <li>A <code>delegate</code> type represents references to methods with a particular parameter list and return type. Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters. Delegates are analogous to function types provided by functional languages. They're also similar to the concept of function pointers found in some other languages. Unlike function pointers, delegates are object-oriented and type-safe.</li>
                    </ul>
                    <p>
                        The <code>class</code>, <code>struct</code>, <code>interface</code>, and <code>delegate</code> types all support generics, whereby they can be parameterized with other types.
                    </p>
                    <p>
                        C# supports single- and multi-dimensional arrays of any type. Unlike the types listed above, array types don't have to be declared before they can be used. Instead, array types are constructed by following a type name with square brackets. For example, <code>int[]</code> is a single-dimensional array of <code>int</code>, <code>int[,]</code> is a two-dimensional array of <code>int</code>, and <code>int[][]</code> is a single-dimensional array of single-dimensional array or "jagged" array of <code>int</code>.
                    </p>
                    <p>
                        Nullable types don't require a separate definition. For each non-nullable type <code>T</code>, there's a corresponding nullable type <code>T?</code>, which can hold an additional value, <code>null</code>. For instance, <code>int?</code> is a type that can hold any 32-bit integer or the value <code>null</code>, and <code>string?</code> is a type that can hold any <code>string</code> or the value <code>null</code>.
                    </p>
                    <p>
                        C#'s type system is unified such that a value of any type can be treated as an <code>object</code>. Every type in C# directly or indirectly derives from the <code>object</code> class type, and <code>object</code> is the ultimate base class of all types. Values of reference types are treated as objects simply by viewing the values as type <code>object</code>. Values of value types are treated as objects by performing <em>boxing</em> and <em>unboxing operations</em>. In the following example, an <code>int</code> value is converted to <code>object</code> and back again to <code>int</code>.
                    </p>
                    <div>
                        <pre>
                            <code>
<span class="code-keyword">int</span> i = 123;
<span class="code-keyword">object</span> o = i;     <span class="code-comment">// Boxing</span>
<span class="code-keyword">int</span> j = (<span class="code-keyword">int</span>)o;   <span class="code-comment">// Unboxing</span>
                            </code>
                        </pre>
                    </div>
                    <p>
                        When a value of a value type is assigned to an <code>object</code> reference, a "box" is allocated to hold the value. That box is an instance of a reference type, and the value is copied into that box. Conversely, when an <code>object</code> reference is cast to a value type, a check is made that the referenced <code>object</code> is a box of the correct value type. If the check succeeds, the value in the box is copied to the value type
                    </p>
                    <p>
                        C#'s unified type system effectively means that value types are treated as <code>object</code> references "on demand." Because of the unification, general-purpose libraries that use type <code>object</code> can be used with all types that derive from <code>object</code>, including both reference types and value types.
                    </p>
                    <p>
                        There are several kinds of <em>variables</em> in C#, including fields, array elements, local variables, and parameters. Variables represent storage locations. Every variable has a type that determines what values can be stored in the variable, as shown below.
                    </p>
                    <ul>
                        <li>Non-nullable value type</li>
                        <ul>
                            <li>A value of that exact type</li>
                        </ul>
                        <li>Nullable value type</li>
                        <ul>
                            <li>A <code>null</code> value or a value of that exact type</li>
                        </ul>
                        <li>object</li>
                        <ul>
                            <li>A <code>null</code> reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</li>
                        </ul>
                        <li>Interface type</li>
                        <ul>
                            <li>A <code>null</code> reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</li>
                        </ul>
                        <li>Array type</li>
                        <ul>
                            <li>A <code>null</code> reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</li>
                        </ul>
                        <li>Delegate type</li>
                        <ul>
                            <li>A <code>null</code> reference or a reference to an instance of a compatible delegate type</li>
                        </ul>
                    </ul>
                </article>
            </section>

            <section id="program-structure">
                <header>
                    <h3>Program Structure</h3>
                </header>
                <article>
                    <p>
                        The key organizational concepts in C# are <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/"><em><strong>programs</strong></em></a>, <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/namespaces/"><em><strong>namespaces</strong></em></a>, <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/"><em><strong>types</strong></em></a>, <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/members"><em><strong>members</strong></em></a>, and <a href="https://docs.microsoft.com/en-us/dotnet/standard/assembly/"><em><strong>assemblies</strong></em></a>. Programs declare types, which contain members and can be organized into namespaces. Classes, structs, and interfaces are examples of types. Fields, methods, properties, and events are examples of members. When C# programs are compiled, they're physically packaged into assemblies. Assemblies typically have the file extension <code>.exe</code> or <code>.dll</code>, depending on whether they implement <em><strong>applications</strong></em> or <em><strong>libraries</strong></em>, respectively.
                    </p>
                    <p>
                        As a small example, consider an assembly that contains the following code:
                    </p>
                    <div>
                        <pre>
                            <code>
<span class="code-keyword">using</span> System;

<span class="code-keyword">namespace</span> <span class="code-title">Acme.Collections</span>
{
    <span class="code-keyword">public class</span> <span class="code-title">Stack</span>&lt;<span class="code-title">T</span>&gt;
    {
        Entry _top;

        <span class="code-keyword">public void</span> <span class="code-title">Push(T data)</span>
        {
            _top = <span class="code-keyword">new</span> Entry(_top, data);
        }

        <span class="code-keyword">public</span> T <span class="code-title">Pop</span>()
        {
            <span class="code-keyword">if</span> (_top == null)
            {
                <span class="code-keyword">throw new</span> InvalidOperationException();
            }
            T result = _top.Data;
            _top = _top.Next;

            <span class="code-keyword">return</span> result;
        }

        <span class="code-keyword">class</span> <span class="code-title">Entry</span>
        {
            <span class="code-keyword">public</span> Entry Next { <span class="code-keyword">get</span>; <span class="code-keyword">set</span>; }
            <span class="code-keyword">public</span> T Data { <span class="code-keyword">get</span>; <span class="code-keyword">set</span>; }

            <span class="code-keyword">public</span> <span class="code-title">Entry</span>(Entry next, T data)
            {
                Next = next;
                data = data;
            }
        }
    }
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        The fully qualified name of this class is <code>Acme.Collections.Stack</code>. The class contains several members: a field named <code>top</code>, two methods named <code>Push</code> and <code>Pop</code>, and a nested class named <code>Entry</code>. The <code>Entry</code> class further contains three members: a field named <code>next</code>, a field named <code>data</code>, and a constructor. The <code>Stack</code> is a <em>generic</em> class. It has one type parameter, <code>T</code> that is replaced with a concrete type when it's used.
                    </p>
                    <div class="note">
                        <p>Note</p>
                        <p>
                            A <em>stack</em> is a "first in - last out" (FILO) collection. New elements are added to the top of the stack. When an element is removed, it is removed from the top of the stack.
                        </p>
                    </div>
                    <p>
                        Assemblies contain executable code in the form of Intermediate Language (IL) instructions, and symbolic information in the form of metadata. Before it's executed, the Just-In-Time (JIT) compiler of .NET Common Language Runtime converts the IL code in an assembly to processor-specific code.
                    </p>
                    <p>
                        Because an assembly is a self-describing unit of functionality containing both code and metadata, there's no need for <code>#include</code> directives and header files in C#. The public types and members contained in a particular assembly are made available in a C# program simply by referencing that assembly when compiling the program. For example, this program uses the <code>Acme.Collections.Stack</code> class from the <code>acme.dll</code> assembly:
                    </p>
                    <div>
                        <pre>
                            <code>
<span class="code-keyword">using</span> System;
<span class="code-keyword">using</span> Acme.Collections;

<span class="code-keyword">class</span> <span class="code-title">Example</span>
{
    <span class="code-keyword">public static void</span> <span class="code-title">Main</span>()
    {
        <span class="code-keyword">var</span> s = <span class="code-keyword">new</span> Stack&lt;<span class="code-keyword">int</span>&gt;();
        s.push(1); <span class="code-comment">// stack contains 1</span>
        s.push(10); <span class="code-comment">// stack contains 10</span>
        s.push(100); <span class="code-comment">// stack contains 100</span>
        Console.WriteLine(s.Pop()); <span class="code-comment">// stack contains 1, 10</span>
        Console.WriteLine(s.Pop()); <span class="code-comment">// stack contains 1</span>
        Console.WriteLine(s.Pop()); <span class="code-comment">// stack is empty</span>
    }
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        To compile this program, you would need to <em>reference</em> the assembly containing the stack class defined in the earlier example.
                    </p>
                    <p>
                        C# programs can be stored in several source files. When a C# program is compiled, all of the source files are processed together, and the source files can freely reference each other. Conceptually, it's as if all the source files were concatenated into one large file before being processed. Forward declarations are never needed in C# because, with few exceptions, declaration order is insignificant. C# doesn't limit a source file to declaring only one public type nor does it require the name of the source file to match a type declared in the source file.
                    </p>
                    <p>
                        Further articles in this tour explain these organizational blocks.
                    </p>
                </article>
            </section>

        </section>

        <section id="types">
            <header>
                <h2>Types</h2>
            </header>
            <article></article>

            <section id="classes-and-objects">
                <header>
                    <h3>Classes and Objects</h3>
                </header>
                <article>
                    <p>
                        <em>Classes</em> are the most fundamental of C#’s types. A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit. A class provides a definition for <em>instances</em> of the class, also known as <em>objects</em>. Classes support <em>inheritance</em> and <em>polymorphism</em>, mechanisms whereby <em>derived classes</em> can extend and specialize <em>base classes</em>.
                    </p>
                    <p>
                        New classes are created using class declarations. A class declaration starts with a header. The header specifies:
                    </p>
                    <ul>
                        <li>The attributes and modifiers of the class</li>
                        <li>The name of the class</li>
                        <li>The base class (when inheriting from a <a href="https://docs.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/types#base-classes">base class</a>)</li>
                        <li>The interfaces implemented by the class</li>
                    </ul>
                    <p>
                        The header is followed by the class body, which consists of a list of member declarations written between the delimiters <code>{</code> and <code>}</code>.
                    </p>
                    <p>
                        The following code shows a declaration of a simple class named <code>Point</code>:
                    </p>
                    <div>
                        <pre>
                            <code>
<span class="code-keyword">public class</span> <span class="code-title">Point</span>
{
    <span class="code-keyword">public int</span> X { <span class="code-keyword">get</span>;}
    <span class="code-keyword">public int</span> Y { <span class="code-keyword">get</span>;}

    <span class="code-keyword">public</span> <span class="code-title">Point</span>(<span class="code-keyword">int</span> x, <span class="code-keyword">int</span> y) => (X, Y) = (x, y);
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        Instances of classes are created using the <code>new</code> operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance. The following statements create two <code>Point</code> objects and store references to those objects in two variables:
                    </p>
                    <div>
                        <pre>
                            <code>
<span class="code-keyword">var</span> p1 = <span class="code-keyword">new</span> Point(0, 0);
<span class="code-keyword">var</span> p2 = <span class="code-keyword">new</span> Point(10, 20);
                            </code>
                        </pre>
                    </div>
                    <p>
                        The memory occupied by an object is automatically reclaimed when the object is no longer reachable. It's neither necessary nor possible to explicitly deallocate objects in C#.
                    </p>
                </article>
            </section>

            <section id="type-parameters">
                <header>
                    <h3>Type Parameters</h3>
                </header>
                <article>
                    <p>
                        Generic classes define <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/"><em><strong>type parameters</strong></em></a>. Type parameters are a list of type parameter names enclosed in angle brackets. Type parameters follow the class name. The type parameters can then be used in the body of the class declarations to define the members of the class. In the following example, the type parameters of <code>Pair</code> are <code>TFirst</code> and <code>TSecond</code>:
                    </p>
                    <div>
                        <pre>
                            <code>
<span class="code-keyword">public class</span> <span class="code-title">Pair</span>&lt;<span class="code-title">TFirst</span>, <span class="code-title">TSecond</span>&gt;
{
    <span class="code-keyword">public</span> TFirst First { <span class="code-keyword">get</span>; }
    <span class="code-keyword">public</span> TSecond Second { <span class="code-keyword">get</span>; }

    <span class="code-keyword">public</span> <span class="code-title">Pair</span>(TFirst first, TSecond second) =>
        (First, Second) = (first, second);
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        A class type that is declared to take type parameters is called a <em>generic class type</em>. Struct, interface, and delegate types can also be generic. When the generic class is used, type arguments must be provided for each of the type parameters:
                    </p>
                    <div>
                        <pre>
                            <code>
<span class="code-keyword">var</span> pair = <span class="code-keyword">new</span> Pair&lt;<span class="code-keyword">int</span>, <span class="code-keyword">string</span>&gt;(1, <span class="code-string">"two"</span>);
<span class="code-keyword">int</span> i = pair.First;       <span class="code-comment">// TFirst int</span>
<span class="code-keyword">string</span> s = pair.Second;   <span class="code-comment">// TSecond string</span>
                            </code>
                        </pre>
                    </div>
                    <p>
                        A generic type with type arguments provided, like <code>Pair&lt;int,string&gt;</code> above, is called a <em>constructed type</em>.
                    </p>
                </article>
            </section>

            <section id="base-classes">
                <header>
                    <h3>Base Classes</h3>
                </header>
                <article>
                    <p>
                        A class declaration may specify a base class. Follow the class name and type parameters with a colon and the name of the base class. Omitting a base class specification is the same as deriving from type <code>object</code>. In the following example, the base class of <code>Point3D</code> is <code>Point</code>. From the first example, the base class of <code>Point</code> is <code>object</code>:
                    </p>
                    <div>
                        <pre>
                            <code>
<span class="code-keyword">public class</span> <span class="code-title">Point3D</span> : <span class="code-title">Point</span>
{
    <span class="code-keyword">public int</span> Z { <span class="code-keyword">get</span>; <span class="code-keyword">set</span>; }

    <span class="code-keyword">public</span> <span class="code-title">Point3D</span>(<span class="code-keyword">int</span> x, <span class="code-keyword">int</span> y, <span class="code-keyword">int</span> z) : <span class="code-title">base</span>(x, y)
    {
        Z = z;
    }
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        A class inherits the members of its base class. Inheritance means that a class implicitly contains almost all members of its base class. A class doesn't inherit the instance and static constructors, and the finalizer. A derived class can add new members to those members it inherits, but it can't remove the definition of an inherited member. In the previous example, <code>Point3D</code> inherits the <code>X</code> and <code>Y</code> members from <code>Point</code>, and every <code>Point3D</code> instance contains three properties, <code>X</code>, <code>Y</code>, and <code>Z</code>.
                    </p>
                    <p>
                        An implicit conversion exists from a class type to any of its base class types. A variable of a class type can reference an instance of that class or an instance of any derived class. For example, given the previous class declarations, a variable of type <code>Point</code> can reference either a <code>Point</code> or a <code>Point3D</code>:
                    </p>
                    <div>
                        <pre>
                            <code>
Point a = <span class="code-keyword">new</span> Point(10, 20);
Point b = <span class="code-keyword">new</span> Point3D(10, 20, 30);
                            </code>
                        </pre>
                    </div>
                </article>
            </section>

            <section id="structs">
                <header>
                    <h3>Structs</h3>
                </header>
                <article>
                    <p>
                        Classes define types that support inheritance and polymorphism. They enable you to create sophisticated behaviors based on hierarchies of derived classes. By contrast, <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/struct"><em><strong>struct</strong></em></a> types are simpler types whose primary purpose is to store data values. Structs can't declare a base type; they implicitly derive from <a href="https://docs.microsoft.com/en-us/dotnet/api/system.valuetype">System.ValueType</a>. You can't derive other <code>struct</code> types from a <code>struct</code> type. They're implicitly sealed.
                    </p>
                    <div>
                        <pre>
                            <code>
<span class="code-keyword">public struct</span> Point
{
    <span class="code-keyword">public double</span> X { <span class="code-keyword">get</span>; }
    <span class="code-keyword">public double</span> Y { <span class="code-keyword">get</span>; }

    <span class="code-keyword">public</span> <span class="code-title">Point</span>(<span class="code-keyword">double</span> x, <span class="code-keyword">double</span> y) => (X, Y) = (x, y);
}
                            </code>
                        </pre>
                    </div>
                </article>
            </section>

            <section id="interfaces">
                <header>
                    <h3>Interfaces</h3>
                </header>
                <article>
                    <p>
                        An <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/interfaces/"><em><strong>interface</strong></em></a> defines a contract that can be implemented by classes and structs. An interface can contain methods, properties, events, and indexers. An interface typically doesn't provide implementations of the members it defines—it merely specifies the members that must be supplied by classes or structs that implement the interface.
                    </p>
                    <p>
                        Interfaces may employ <em><strong>multiple inheritance</strong></em>. In the following example, the interface <code>IComboBox</code> inherits from both <code>ITextBox</code> and <code>IListBox</code>.
                    </p>
                    <div>
                        <pre>
                            <code>
<span class="code-keyword">interface</span> <span class="code-title">IControl</span>
{
    <span class="code-keyword">void</span> <span class="code-title">Paint</span>();
}

<span class="code-keyword">interface</span> <span class="code-title">ITextBox</span> : <span class="code-title">IControl</span>
{
    <span class="code-keyword">void</span> <span class="code-title">SetText</span>(<span class="code-keyword">string</span> text);
}

<span class="code-keyword">interface</span> <span class="code-title">IListBox</span> : <span class="code-title">IControl</span>
{
    <span class="code-keyword">void</span> <span class="code-title">SetItems</span>(<span class="code-keyword">string</span>[] items);
}

<span class="code-keyword">interface</span> <span class="code-title">IComboBox</span> : <span class="code-title">ITextBox</span>, <span class="code-title">IListBox</span> { }
                            </code>
                        </pre>
                    </div>
                    <p>
                        Classes and structs can implement multiple interfaces. In the following example, the class <code>EditBox</code> implements both <code>IControl</code> and <code>IDataBound</code>.
                    </p>
                    <div>
                        <pre>
                            <code>
<span class="code-keyword">interface</span> <span class="code-title">IDataBound</span>
{
    <span class="code-keyword">void</span> <span class="code-title">Bind</span>(Binder b);
}

<span class="code-keyword">public class</span> <span class="code-title">EditBox</span> : <span class="code-title">IControl</span>, <span class="code-title">IDataBound</span>
{
    <span class="code-keyword">public void</span> <span class="code-title">Paint</span>() { }
    <span class="code-keyword">public void</span> <span class="code-title">Bind</span>(Binder b) { }    
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        When a class or struct implements a particular interface, instances of that class or struct can be implicitly converted to that interface type. For example
                    </p>
                    <div>
                        <pre>
                            <code>
EditBox editBox = <span class="code-keyword">new</span> EditBox();
IControl control = editBox;
IDataBound dataBound = editBox;
                            </code>
                        </pre>
                    </div>
                </article>
            </section>

            <section id="enums">
                <header>
                    <h3>Enums</h3>
                </header>
                <article>
                    <p>
                        An <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum"><em><strong>Enum</strong></em></a> type defines a set of constant values. The following <code>enum</code> declares constants that define different root vegetables:
                    </p>
                    <div>
                        <pre>
                            <code>
<span class="code-keyword">public enum</span> SomeRootVegetables
{
    HorseRadish,
    Radish,
    Turnip
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        You can also define an <code>enum</code> to be used in combination as flags. The following declaration declares a set of flags for the four seasons. Any combination of the seasons may be applied, including an <code>All</code> value that includes all seasons:
                    </p>
                    <div>
                        <pre>
                            <code>
[<span class="code-title">Flags</span>]
<span class="code-keyword">public enum</span> Seasons
{
    None = 0,,
    Summer = 1,
    Autumn = 2,
    Winter = 4,
    Spring = 8,
    All = Summer | Autumn | Winter | Spring
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        The following example shows declarations of both the preceding enums:
                    </p>
                    <div>
                        <pre>
                            <code>
<span class="code-keyword">var</span> turnip = SomeRootVegetables.Turnip;

<span class="code-keyword">var</span> spring = Seasons.Spring;
<span class="code-keyword">var</span> startingOnEquinox = Seasons.Spring | Seasons.Autumn;
<span class="code-keyword">var</span> theYear = Seasons.All;
                            </code>
                        </pre>
                    </div>
                </article>
            </section>

            <section id="nullable types">
                <header>
                    <h3>Nullable Types</h3>
                </header>
                <article>
                    <p>
                        Variables of any type may be declared as <em><strong>non-nullable</strong></em> or <em><strong>nullable</strong></em>. A nullable variable can hold an additional <code>null</code> value, indicating no value. Nullable Value types (structs or enums) are represented by <a href="https://docs.microsoft.com/en-us/dotnet/api/system.nullable-1">System.Nullable&lt;T&gt;</a>. Non-nullable and Nullable Reference types are both represented by the underlying reference type. The distinction is represented by metadata read by the compiler and some libraries. The compiler provides warnings when nullable references are dereferenced without first checking their value against <code>null</code>. The compiler also provides warnings when non-nullable references are assigned a value that may be <code>null</code>. The following example declares a <em><strong>nullable int</strong></em>, initializing it to <code>null</code>. Then, it sets the value to <code>5</code>. It demonstrates the same concept with a <em><strong>nullable string</strong></em>. For more information, see <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-value-types">nullable value types</a> and <a href="https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references">nullable reference types</a>.
                    </p>
                    <div>
                        <pre>
                            <code>
<span class="code-keyword">int</span>? optionalInt = <span class="code-keyword">default</span>;
optionalInt = 5;
<span class="code-keyword">string</span>? optionalText = <span class="code-keyword">default</span>;
optionalText = <span class="code-string">"Hello World."</span>;
                            </code>
                        </pre>
                    </div>
                </article>
            </section>

            <section id="tuples">
                <header>
                    <h3>Tuples</h3>
                </header>
                <article>
                    <p>
                        C# supports <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-tuples"><em><strong>tuples</strong></em></a>, which provides concise syntax to group multiple data elements in a lightweight data structure. You instantiate a tuple by declaring the types and names of the members between <code>(</code> and <code>)</code>, as shown in the following example:
                    </p>
                    <div>
                        <pre>
                            <code>
(<span class="code-keyword">double</span> Sum, <span class="code-keyword">int</span> Count) t2 = (4.5, 3);
Console.WriteLine(<span class="code-string">$"Sum of </span>{t2.Count} <span class="code-string">elements is</span> {t2.Sum}<span class="code-string">."</span>);
<span class="code-comment">// Output:</span>
<span class="code-comment">// Sum of 3 elements is 4.5.</span>
                            </code>
                        </pre>
                    </div>
                    <p>
                        Tuples provide an alternative for data structure with multiple members, without using the building blocks described in the next article.
                    </p>
                </article>
            </section>

        </section>

        <section id="program-building-blocks">
            <header>
                <h2>Program Building Blocks</h2>
            </header>
            <article>
                <p>
                    The types described in the previous article are built using these building blocks: <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/members"><em><strong>members</strong></em></a>, <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/"><em><strong>expressions</strong></em>, and <em><strong>statements</strong></em></a>.
                </p>
            </article>

            <section id="members">
                <header>
                    <h3>Members</h3>
                </header>
                <article></article>
            </section>

            <section id="accessibility">
                <header>
                    <h3>Accessibility</h3>
                </header>
                <article></article>
            </section>

            <section id="fields">
                <header>
                    <h3>Fields</h3>
                </header>
                <article></article>
            </section>

            <section id="methods">
                <header>
                    <h3>Methods</h3>
                </header>
                <article></article>
            </section>

            <section id="parameters">
                <header>
                    <h3>Parameters</h3>
                </header>
                <article></article>
            </section>

            <section id="method-body-and-local-variables">
                <header>
                    <h3>Method Body and Local Variables</h3>
                </header>
                <article></article>
            </section>

            <section id="static-and-instance-methods">
                <header>
                    <h3>Static and Instance Methods</h3>
                </header>
                <article></article>
            </section>

            <section id="virtual-override-and-abstract-methods">
                <header>
                    <h3>Virtual, Override and Abstract Methods</h3>
                </header>
                <article></article>
            </section>

            <section id="method-overloading">
                <header>
                    <h3>Method Overloading</h3>
                </header>
                <article></article>
            </section>

            <section id="other-function-methods">
                <header>
                    <h3>Other Function Members</h3>
                </header>
                <article></article>
            </section>

            <section id="constructors">
                <header>
                    <h3>Constructors</h3>
                </header>
                <article></article>
            </section>

            <section id="properties">
                <header>
                    <h3>Properties</h3>
                </header>
                <article></article>
            </section>

            <section id="indexers">
                <header>
                    <h3>Indexers</h3>
                </header>
                <article></article>
            </section>

            <section id="events">
                <header>
                    <h3>Events</h3>
                </header>
                <article></article>
            </section>

            <section id="operators">
                <header>
                    <h3>Operators</h3>
                </header>
                <article></article>
            </section>

            <section id="finalizers">
                <header>
                    <h3>Finalizers</h3>
                </header>
                <article></article>
            </section>

            <section id="expressions">
                <header>
                    <h3>Expressions</h3>
                </header>
                <article></article>
            </section>

            <section id="statements">
                <header>
                    <h3>Statements</h3>
                </header>
                <article></article>
            </section>

        </section>

        <section id="major-language-areas">
            <header>
                <h2>Major Language Areas</h2>
            </header>
            <article></article>

            <section id="arrays-collections-and-linq">
                <header>
                    <h3>Arrays, Collections and LINQ</h3>
                </header>
                <article></article>
            </section>

            <section id="arrays">
                <header>
                    <h3>Arrays</h3>
                </header>
                <article></article>
            </section>

            <section id="string-interpolation">
                <header>
                    <h3>String Interpolation</h3>
                </header>
                <article></article>
            </section>

            <section id="pattern-matching">
                <header>
                    <h3>Pattern Matching</h3>
                </header>
                <article></article>
            </section>

            <section id="delegates-and-llambda-expressions">
                <header>
                    <h3>Delegates and Llambda Expressions</h3>
                </header>
                <article></article>
            </section>

            <section id="async-await">
                <header>
                    <h3>Async / Await</h3>
                </header>
                <article></article>
            </section>

            <section id="attributes">
                <header>
                    <h3>Attributes</h3>
                </header>
                <article></article>
            </section>

        </section>

    </main>

    <footer>

    </footer>

</body>