<!DOCTYPE html>
<html lang="en">

<head>
    <title>A Tour of C#</title>
    <link rel="stylesheet" type="text/css" href="./CSS/index.css">
    <meta name="description" content="A Tour of C# - Technical Doocumentation Page">
    <meta name="author" content="David Price">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8" />
</head>

<body>

    <nav id="navbar" class="navbar">
        <div class="nav-icon" onclick="expandCollapseNav()">
            <div></div>
        </div>
        <header>
            <h1>A Tour of C#</h1>
        </header>
        <ul id="nav-list">
            <li><a class="nav-link" href="#A_Tour_of_the_C#_Language">A Tour of the C# Language</a>
                <ul>
                    <li><a class="nav-link-sub" href="#hello-world">Hello World</a></li>
                    <li><a class="nav-link-sub" href="#types-and-variables">Types & Variables</a></li>
                    <li><a class="nav-link-sub" href="#program-structure">Program Structure</a></li>
                </ul>
            </li>
            <li><a class="nav-link" href="#Types">Types</a>
                <ul>
                    <li><a class="nav-link-sub" href="#classes-and-objects">Classes and Objects</a></li>
                    <li><a class="nav-link-sub" href="#type-parameters">Type Parameters</a></li>
                    <li><a class="nav-link-sub" href="#base-classes">Base Classes</a></li>
                    <li><a class="nav-link-sub" href="#structs">Structs</a></li>
                    <li><a class="nav-link-sub" href="#interfaces">Interfaces</a></li>
                    <li><a class="nav-link-sub" href="#enums">Enums</a></li>
                    <li><a class="nav-link-sub" href="#nullable-types">Nullable Types</a></li>
                    <li><a class="nav-link-sub" href="#tuples">Tuples</a></li>
                </ul>
            </li>
            <li><a class="nav-link" href="#Program_Building_Blocks">Program Building Blocks</a>
                <ul>
                    <li><a class="nav-link-sub" href="#members">Members</a></li>
                    <li><a class="nav-link-sub" href="#accessibility">Accessibility</a></li>
                    <li><a class="nav-link-sub" href="#fields">Fields</a></li>
                    <li><a class="nav-link-sub" href="#methods">Methods</a></li>
                    <li><a class="nav-link-sub" href="#parameters">Parameters</a></li>
                    <li><a class="nav-link-sub" href="#method-body-and-local-variables">Method Body and Local Variables</a>
                    </li>
                    <li><a class="nav-link-sub" href="#static-and-instance-methods">Static and Instance Methods</a></li>
                    <li><a class="nav-link-sub" href="#virtual-override-and-abstract-methods">Virtual, Override and Abstract
                            Methods</a></li>
                    <li><a class="nav-link-sub" href="#method-overloading">Method Overloading</a></li>
                    <li><a class="nav-link-sub" href="#other-function-members">Other Function Members</a></li>
                    <li><a class="nav-link-sub" href="#constructors">Constructors</a></li>
                    <li><a class="nav-link-sub" href="#properties">Properties</a></li>
                    <li><a class="nav-link-sub" href="#indexers">Indexers</a></li>
                    <li><a class="nav-link-sub" href="#events">Events</a></li>
                    <li><a class="nav-link-sub" href="#operators">Operators</a></li>
                    <li><a class="nav-link-sub" href="#finalizers">Finalizers</a></li>
                    <li><a class="nav-link-sub" href="#expressions">Expressions</a></li>
                    <li><a class="nav-link-sub" href="#statements">Statements</a></li>
                </ul>
            </li>
            <li><a class="nav-link" href="#Major_Language_Areas">Major Language Areas</a>
                <ul>
                    <li><a class="nav-link-sub" href="#arrays-collections-and-linq">Arrays, Collections and LINQ</a></li>
                    <li><a class="nav-link-sub" href="#arrays">Arrays</a></li>
                    <li><a class="nav-link-sub" href="#string-interpolation">String Interpolation</a></li>
                    <li><a class="nav-link-sub" href="#pattern-matching">Pattern Matching</a></li>
                    <li><a class="nav-link-sub" href="#delegates-and-llambda-expressions">Delegates and Llambda
                            Expressions</a></li>
                    <li><a class="nav-link-sub" href="#async-await">Async / Await</a></li>
                    <li><a class="nav-link-sub" href="#attributes">Attributes</a></li>
                </ul>
            </li>
            <li><a class="nav-link" href="#Conclusion">Conclusion</a>
        </ul>
    </nav>

    <main id="main-doc">
        <section id="A_Tour_of_the_C#_Language" class="main-section">
            <header>
                <h2>A Tour of the C# Language</h2>
            </header>
            <article>
                <p>C# (pronounced "See Sharp") is a modern, object-oriented, and type-safe programming language. C# has
                    its roots in the C family of languages and will be immediately familiar to C, C++, Java, and
                    JavaScript programmers. This tour provides an overview of the major components of the language in C#
                    8 and earlier. If you want to explore the language through interactive examples, try the
                    <a href="https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/intro-to-csharp/">introduction to
                        C#</a> tutorials.</p>
                <p>C# is an object-oriented, <strong>component-oriented</strong> programming language. C# provides
                    language constructs to
                    directly support these concepts, making C# a natural language in which to create and use software
                    components. Since its origin, C# has added features to support new workloads and emerging software
                    design practices.</p>
                <p>Several C# features aid in the construction of robust and durable applications. <a
                        href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/">Garbage
                        collection</a>
                    automatically reclaims memory occupied by unreachable unused objects. <a
                        href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/exceptions/">Exception
                        handling</a> provides a
                    structured and extensible approach to error detection and recovery. <a
                        href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/lambda-expressions">Lambda
                        expressions</a> support
                    functional programming techniques. <a
                        href="https://docs.microsoft.com/en-us/dotnet/csharp/linq/">Query syntax</a> creates a common
                    pattern for working with data from
                    any source. Language support for <a
                        href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/">asynchronous
                        operations</a> provides syntax for building distributed
                    systems. <a href="https://docs.microsoft.com/en-us/dotnet/csharp/pattern-matching">Pattern
                        matching</a> provides syntax to easily separate data from algorithms in modern
                    distributed systems. C# has a <a
                        href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/">unified type
                        system</a>. All C# types, including primitive types such as
                    <code>int</code> and <code>double</code>, inherit from a single root <code>object</code> type. All
                    types share a set of common operations.
                    Values of any type can be stored, transported, and operated upon in a consistent manner.
                    Furthermore, C# supports both user-defined reference types and value types. C# allows dynamic
                    allocation of objects and in-line storage of lightweight structures.</p>
                <p>C# emphasizes <strong>versioning</strong> to ensure programs and libraries can evolve over time in a
                    compatible
                    manner. Aspects of C#'s design that were directly influenced by versioning considerations include
                    the separate <code>virtual</code> and <code>override</code> modifiers, the rules for method overload
                    resolution, and support
                    for explicit interface member declarations.</p>
            </article>

            <section id="hello-world">
                <header>
                    <h3>Hello World</h3>
                </header>
                <article>
                    <p>The "Hello, World" program is traditionally used to introduce a programming language. Here it is
                        in C#:</p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">using</span> System;

<span class="code-keyword">class</span> <span class="code-title">Hello</span>
{
    <span class="code-keyword">static void</span> <span class="code-title">Main</span>()
    {
        Console.WriteLine(<span class="code-string">"Hello, world"</span>);
    }
}
                            </code>
                        </pre>
                    </div>
                </article>
            </section>

            <section id="types-and-variables">
                <header>
                    <h3>Types and Variables</h3>
                </header>
                <article>
                    <p>
                        There are two kinds of types in C#: <em>value types</em> and <em>reference types</em>. Variables
                        of value types
                        directly contain their data whereas variables of reference types store references to their data,
                        the latter being known as objects. With reference types, it's possible for two variables to
                        reference the same object and possible for operations on one variable to affect the object
                        referenced by the other variable. With value types, the variables each have their own copy of
                        the data, and it isn't possible for operations on one to affect the other (except for
                        <code>ref</code> and
                        <code>out</code> parameter variables).
                    </p>
                    <p>
                        An <strong><em>identifier</em></strong> is a variable name. An identifier is a sequence of
                        unicode characters without any
                        whitespace. An identifier may be a C# reserved word, if it is prefixed by <code>@</code>. That
                        can be useful
                        when interacting with other languages.
                    </p>
                    <p>
                        C#'s value types are further divided into <em>simple types</em>, <em>enum types</em>, <em>struct
                            types</em>, and <em>nullable
                            value types</em>. C#'s reference types are further divided into <em>class types</em>,
                        <em>interface types</em>, <em>array
                            types</em>, and <em>delegate types</em>.
                    </p>
                    <p>
                        The following outline provides an overview of C#'s type system.
                    </p>
                    <ul>
                        <li><a
                                href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-types">Value
                                types</a></li>
                        <ul>
                            <li><a
                                    href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-types#built-in-value-types">Simple
                                    types</a></li>
                            <ul>
                                <li><a
                                        href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/integral-numeric-types">Signed
                                        integral</a>: <code>sbyte</code>, <code>short</code>, <code>int</code>,
                                    <code>long</code></li>
                                <li><a
                                        href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/integral-numeric-types">Unsigned
                                        integral</a>: <code>byte</code>, <code>ushort</code>, <code>uint</code>,
                                    <code>ulong</code></li>
                                <li><a
                                        href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/character-encoding-introduction">Unicode
                                        characters</a>: <code>char</code>, which represents a UTF-16 code unit</li>
                                <li><a
                                        href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types">IEEE
                                        binary floating-point</a>: <code>float</code>, <code>double</code></li>
                                <li><a
                                        href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types">High-precision
                                        decimal floating-point</a>: <code>decimal</code></li>
                                <li>Boolean: <code>bool</code>, which represents Boolean values - values that are either
                                    <code>true</code> or <code>false</code></li>
                            </ul>
                            <li><a
                                    href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum">Enum
                                    types</a></li>
                            <ul>
                                <li>User-defined types of the form <code>enum E {...}</code>. An <code>enum</code> type
                                    is a distinct type with named constants. Every <code>enum</code> type has an
                                    underlying type, which must be one of the eight intergral types. The set of values
                                    of an <code>enum</code> type is the same as the set of values of the underlying
                                    type.</li>
                            </ul>
                            <li><a
                                    href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/struct">Struct
                                    types</a></li>
                            <ul>
                                <li>User-defined types of the form <code>struct S {...}</code></li>
                            </ul>
                            <li><a
                                    href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-value-types">Nullable
                                    value types</a></li>
                            <ul>
                                <li>Extensions of all other value types with a <code>null</code> value</li>
                            </ul>
                            <li><a href="">Tuple value types</a></li>
                            <ul>
                                <li>User-defined types of the form <code>(T1, T2, ...)</code></li>
                            </ul>
                        </ul>
                        <li><a
                                href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/reference-types">Reference
                                types</a></li>
                        <ul>
                            <li><a
                                    href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/class">Class
                                    types</a></li>
                            <ul>
                                <li>Ultimate base class of all other types: <code>object</code></li>
                                <li><a
                                        href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/character-encoding-introduction">Unicode
                                        strings</a>: <code>string</code>, which represents a sequence of UTF-16 code
                                    units</li>
                                <li>User-defined types of the form <code>class C {...}</code></li>
                            </ul>
                            <li><a
                                    href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface">Interface
                                    types</a></li>
                            <ul>
                                <li>User-defined types of the form <code>interface I {...}</code></li>
                            </ul>
                            <li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/">Array
                                    types</a></li>
                            <ul>
                                <li>Single- and multi-dimensional and jagged, for example, <code>int[]</code>,
                                    <code>int[,]</code>, and <code>int[][]</code></li>
                            </ul>
                            <li><a
                                    href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/reference-types#the-delegate-type">Delegate
                                    types</a></li>
                            <ul>
                                <li>User-defined types of the form <code>delegate int D(...)</code></li>
                            </ul>
                        </ul>
                    </ul>
                    <p>
                        C# programs use <em>type declarations</em> to create new types. A type declaration specifies the
                        name and
                        the members of the new type. Five of C#'s categories of types are user-definable: class types,
                        struct types, interface types, enum types, and delegate types.
                    </p>
                    <ul>
                        <li>A <code>class</code> type defines a data structure that contains data members (fields) and
                            function members (methods, properties, and others). Class types support single inheritance
                            and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.
                        </li>
                        <li>A <code>struct</code> type is similar to a class type in that it represents a structure with
                            data members and function members. However, unlike classes, structs are value types and
                            don't typically require heap allocation. Struct types don't support user-specified
                            inheritance, and all struct types implicitly inherit from type <code>object</code>.</li>
                        <li>An <code>interface</code> type defines a contract as a named set of public members. A
                            <code>class</code> or <code>struct</code> that implements an <code>interface</code> must
                            provide implementations of the interface's members. An <code>interface</code> may inherit
                            from multiple base interfaces, and a <code>class</code> or <code>struct</code> may implement
                            multiple interfaces.</li>
                        <li>A <code>delegate</code> type represents references to methods with a particular parameter
                            list and return type. Delegates make it possible to treat methods as entities that can be
                            assigned to variables and passed as parameters. Delegates are analogous to function types
                            provided by functional languages. They're also similar to the concept of function pointers
                            found in some other languages. Unlike function pointers, delegates are object-oriented and
                            type-safe.</li>
                    </ul>
                    <p>
                        The <code>class</code>, <code>struct</code>, <code>interface</code>, and <code>delegate</code>
                        types all support generics, whereby they can be parameterized with other types.
                    </p>
                    <p>
                        C# supports single- and multi-dimensional arrays of any type. Unlike the types listed above,
                        array types don't have to be declared before they can be used. Instead, array types are
                        constructed by following a type name with square brackets. For example, <code>int[]</code> is a
                        single-dimensional array of <code>int</code>, <code>int[,]</code> is a two-dimensional array of
                        <code>int</code>, and <code>int[][]</code> is a single-dimensional array of single-dimensional
                        array or "jagged" array of <code>int</code>.
                    </p>
                    <p>
                        Nullable types don't require a separate definition. For each non-nullable type <code>T</code>,
                        there's a corresponding nullable type <code>T?</code>, which can hold an additional value,
                        <code>null</code>. For instance, <code>int?</code> is a type that can hold any 32-bit integer or
                        the value <code>null</code>, and <code>string?</code> is a type that can hold any
                        <code>string</code> or the value <code>null</code>.
                    </p>
                    <p>
                        C#'s type system is unified such that a value of any type can be treated as an
                        <code>object</code>. Every type in C# directly or indirectly derives from the
                        <code>object</code> class type, and <code>object</code> is the ultimate base class of all types.
                        Values of reference types are treated as objects simply by viewing the values as type
                        <code>object</code>. Values of value types are treated as objects by performing <em>boxing</em>
                        and <em>unboxing operations</em>. In the following example, an <code>int</code> value is
                        converted to <code>object</code> and back again to <code>int</code>.
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">int</span> i = 123;
<span class="code-keyword">object</span> o = i;     <span class="code-comment">// Boxing</span>
<span class="code-keyword">int</span> j = (<span class="code-keyword">int</span>)o;   <span class="code-comment">// Unboxing</span>
                            </code>
                        </pre>
                    </div>
                    <p>
                        When a value of a value type is assigned to an <code>object</code> reference, a "box" is
                        allocated to hold the value. That box is an instance of a reference type, and the value is
                        copied into that box. Conversely, when an <code>object</code> reference is cast to a value type,
                        a check is made that the referenced <code>object</code> is a box of the correct value type. If
                        the check succeeds, the value in the box is copied to the value type
                    </p>
                    <p>
                        C#'s unified type system effectively means that value types are treated as <code>object</code>
                        references "on demand." Because of the unification, general-purpose libraries that use type
                        <code>object</code> can be used with all types that derive from <code>object</code>, including
                        both reference types and value types.
                    </p>
                    <p>
                        There are several kinds of <em>variables</em> in C#, including fields, array elements, local
                        variables, and parameters. Variables represent storage locations. Every variable has a type that
                        determines what values can be stored in the variable, as shown below.
                    </p>
                    <ul>
                        <li>Non-nullable value type</li>
                        <ul>
                            <li>A value of that exact type</li>
                        </ul>
                        <li>Nullable value type</li>
                        <ul>
                            <li>A <code>null</code> value or a value of that exact type</li>
                        </ul>
                        <li>object</li>
                        <ul>
                            <li>A <code>null</code> reference, a reference to an instance of that class type, or a
                                reference to an instance of a class derived from that class type</li>
                        </ul>
                        <li>Interface type</li>
                        <ul>
                            <li>A <code>null</code> reference, a reference to an instance of a class type that
                                implements that interface type, or a reference to a boxed value of a value type that
                                implements that interface type</li>
                        </ul>
                        <li>Array type</li>
                        <ul>
                            <li>A <code>null</code> reference, a reference to an instance of that array type, or a
                                reference to an instance of a compatible array type</li>
                        </ul>
                        <li>Delegate type</li>
                        <ul>
                            <li>A <code>null</code> reference or a reference to an instance of a compatible delegate
                                type</li>
                        </ul>
                    </ul>
                </article>
            </section>

            <section id="program-structure">
                <header>
                    <h3>Program Structure</h3>
                </header>
                <article>
                    <p>
                        The key organizational concepts in C# are <a
                            href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/"><em><strong>programs</strong></em></a>,
                        <a
                            href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/namespaces/"><em><strong>namespaces</strong></em></a>,
                        <a
                            href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/"><em><strong>types</strong></em></a>,
                        <a
                            href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/members"><em><strong>members</strong></em></a>,
                        and <a
                            href="https://docs.microsoft.com/en-us/dotnet/standard/assembly/"><em><strong>assemblies</strong></em></a>.
                        Programs declare types, which contain members and can be organized into namespaces. Classes,
                        structs, and interfaces are examples of types. Fields, methods, properties, and events are
                        examples of members. When C# programs are compiled, they're physically packaged into assemblies.
                        Assemblies typically have the file extension <code>.exe</code> or <code>.dll</code>, depending
                        on whether they implement <em><strong>applications</strong></em> or
                        <em><strong>libraries</strong></em>, respectively.
                    </p>
                    <p>
                        As a small example, consider an assembly that contains the following code:
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">using</span> System;

<span class="code-keyword">namespace</span> <span class="code-title">Acme.Collections</span>
{
    <span class="code-keyword">public class</span> <span class="code-title">Stack</span>&lt;<span class="code-title">T</span>&gt;
    {
        Entry _top;

        <span class="code-keyword">public void</span> <span class="code-title">Push(T data)</span>
        {
            _top = <span class="code-keyword">new</span> Entry(_top, data);
        }

        <span class="code-keyword">public</span> T <span class="code-title">Pop</span>()
        {
            <span class="code-keyword">if</span> (_top == null)
            {
                <span class="code-keyword">throw new</span> InvalidOperationException();
            }
            T result = _top.Data;
            _top = _top.Next;

            <span class="code-keyword">return</span> result;
        }

        <span class="code-keyword">class</span> <span class="code-title">Entry</span>
        {
            <span class="code-keyword">public</span> Entry Next { <span class="code-keyword">get</span>; <span class="code-keyword">set</span>; }
            <span class="code-keyword">public</span> T Data { <span class="code-keyword">get</span>; <span class="code-keyword">set</span>; }

            <span class="code-keyword">public</span> <span class="code-title">Entry</span>(Entry next, T data)
            {
                Next = next;
                data = data;
            }
        }
    }
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        The fully qualified name of this class is <code>Acme.Collections.Stack</code>. The class
                        contains several members: a field named <code>top</code>, two methods named <code>Push</code>
                        and <code>Pop</code>, and a nested class named <code>Entry</code>. The <code>Entry</code> class
                        further contains three members: a field named <code>next</code>, a field named
                        <code>data</code>, and a constructor. The <code>Stack</code> is a <em>generic</em> class. It has
                        one type parameter, <code>T</code> that is replaced with a concrete type when it's used.
                    </p>
                    <div class="note">
                        <p>Note</p>
                        <p>
                            A <em>stack</em> is a "first in - last out" (FILO) collection. New elements are added to the
                            top of the stack. When an element is removed, it is removed from the top of the stack.
                        </p>
                    </div>
                    <p>
                        Assemblies contain executable code in the form of Intermediate Language (IL) instructions, and
                        symbolic information in the form of metadata. Before it's executed, the Just-In-Time (JIT)
                        compiler of .NET Common Language Runtime converts the IL code in an assembly to
                        processor-specific code.
                    </p>
                    <p>
                        Because an assembly is a self-describing unit of functionality containing both code and
                        metadata, there's no need for <code>#include</code> directives and header files in C#. The
                        public types and members contained in a particular assembly are made available in a C# program
                        simply by referencing that assembly when compiling the program. For example, this program uses
                        the <code>Acme.Collections.Stack</code> class from the <code>acme.dll</code> assembly:
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">using</span> System;
<span class="code-keyword">using</span> Acme.Collections;

<span class="code-keyword">class</span> <span class="code-title">Example</span>
{
    <span class="code-keyword">public static void</span> <span class="code-title">Main</span>()
    {
        <span class="code-keyword">var</span> s = <span class="code-keyword">new</span> Stack&lt;<span class="code-keyword">int</span>&gt;();
        s.push(1); <span class="code-comment">// stack contains 1</span>
        s.push(10); <span class="code-comment">// stack contains 10</span>
        s.push(100); <span class="code-comment">// stack contains 100</span>
        Console.WriteLine(s.Pop()); <span class="code-comment">// stack contains 1, 10</span>
        Console.WriteLine(s.Pop()); <span class="code-comment">// stack contains 1</span>
        Console.WriteLine(s.Pop()); <span class="code-comment">// stack is empty</span>
    }
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        To compile this program, you would need to <em>reference</em> the assembly containing the stack
                        class defined in the earlier example.
                    </p>
                    <p>
                        C# programs can be stored in several source files. When a C# program is compiled, all of the
                        source files are processed together, and the source files can freely reference each other.
                        Conceptually, it's as if all the source files were concatenated into one large file before being
                        processed. Forward declarations are never needed in C# because, with few exceptions, declaration
                        order is insignificant. C# doesn't limit a source file to declaring only one public type nor
                        does it require the name of the source file to match a type declared in the source file.
                    </p>
                    <p>
                        Further articles in this tour explain these organizational blocks.
                    </p>
                </article>
            </section>

        </section>

        <section id="Types" class="main-section">
            <header>
                <h2>Types</h2>
            </header>
            <article></article>

            <section id="Classes_and_Objects" >
                <header>
                    <h3>Classes and Objects</h3>
                </header>
                <article>
                    <p>
                        <em>Classes</em> are the most fundamental of C#’s types. A class is a data structure that
                        combines state (fields) and actions (methods and other function members) in a single unit. A
                        class provides a definition for <em>instances</em> of the class, also known as <em>objects</em>.
                        Classes support <em>inheritance</em> and <em>polymorphism</em>, mechanisms whereby <em>derived
                            classes</em> can extend and specialize <em>base classes</em>.
                    </p>
                    <p>
                        New classes are created using class declarations. A class declaration starts with a header. The
                        header specifies:
                    </p>
                    <ul>
                        <li>The attributes and modifiers of the class</li>
                        <li>The name of the class</li>
                        <li>The base class (when inheriting from a <a
                                href="https://docs.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/types#base-classes">base
                                class</a>)</li>
                        <li>The interfaces implemented by the class</li>
                    </ul>
                    <p>
                        The header is followed by the class body, which consists of a list of member declarations
                        written between the delimiters <code>{</code> and <code>}</code>.
                    </p>
                    <p>
                        The following code shows a declaration of a simple class named <code>Point</code>:
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">public class</span> <span class="code-title">Point</span>
{
    <span class="code-keyword">public int</span> X { <span class="code-keyword">get</span>;}
    <span class="code-keyword">public int</span> Y { <span class="code-keyword">get</span>;}

    <span class="code-keyword">public</span> <span class="code-title">Point</span>(<span class="code-keyword">int</span> x, <span class="code-keyword">int</span> y) => (X, Y) = (x, y);
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        Instances of classes are created using the <code>new</code> operator, which allocates memory for
                        a new instance, invokes a constructor to initialize the instance, and returns a reference to the
                        instance. The following statements create two <code>Point</code> objects and store references to
                        those objects in two variables:
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">var</span> p1 = <span class="code-keyword">new</span> Point(0, 0);
<span class="code-keyword">var</span> p2 = <span class="code-keyword">new</span> Point(10, 20);
                            </code>
                        </pre>
                    </div>
                    <p>
                        The memory occupied by an object is automatically reclaimed when the object is no longer
                        reachable. It's neither necessary nor possible to explicitly deallocate objects in C#.
                    </p>
                </article>
            </section>

            <section id="Type_Parameters">
                <header>
                    <h3>Type Parameters</h3>
                </header>
                <article>
                    <p>
                        Generic classes define <a
                            href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/"><em><strong>type
                                    parameters</strong></em></a>. Type parameters are a list of type parameter names
                        enclosed in angle brackets. Type parameters follow the class name. The type parameters can then
                        be used in the body of the class declarations to define the members of the class. In the
                        following example, the type parameters of <code>Pair</code> are <code>TFirst</code> and
                        <code>TSecond</code>:
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">public class</span> <span class="code-title">Pair</span>&lt;<span class="code-title">TFirst</span>, <span class="code-title">TSecond</span>&gt;
{
    <span class="code-keyword">public</span> TFirst First { <span class="code-keyword">get</span>; }
    <span class="code-keyword">public</span> TSecond Second { <span class="code-keyword">get</span>; }

    <span class="code-keyword">public</span> <span class="code-title">Pair</span>(TFirst first, TSecond second) =>
        (First, Second) = (first, second);
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        A class type that is declared to take type parameters is called a <em>generic class type</em>.
                        Struct, interface, and delegate types can also be generic. When the generic class is used, type
                        arguments must be provided for each of the type parameters:
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">var</span> pair = <span class="code-keyword">new</span> Pair&lt;<span class="code-keyword">int</span>, <span class="code-keyword">string</span>&gt;(1, <span class="code-string">"two"</span>);
<span class="code-keyword">int</span> i = pair.First;       <span class="code-comment">// TFirst int</span>
<span class="code-keyword">string</span> s = pair.Second;   <span class="code-comment">// TSecond string</span>
                            </code>
                        </pre>
                    </div>
                    <p>
                        A generic type with type arguments provided, like <code>Pair&lt;int,string&gt;</code> above, is
                        called a <em>constructed type</em>.
                    </p>
                </article>
            </section>

            <section id="base-classes">
                <header>
                    <h3>Base Classes</h3>
                </header>
                <article>
                    <p>
                        A class declaration may specify a base class. Follow the class name and type parameters with a
                        colon and the name of the base class. Omitting a base class specification is the same as
                        deriving from type <code>object</code>. In the following example, the base class of
                        <code>Point3D</code> is <code>Point</code>. From the first example, the base class of
                        <code>Point</code> is <code>object</code>:
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">public class</span> <span class="code-title">Point3D</span> : <span class="code-title">Point</span>
{
    <span class="code-keyword">public int</span> Z { <span class="code-keyword">get</span>; <span class="code-keyword">set</span>; }

    <span class="code-keyword">public</span> <span class="code-title">Point3D</span>(<span class="code-keyword">int</span> x, <span class="code-keyword">int</span> y, <span class="code-keyword">int</span> z) : <span class="code-title">base</span>(x, y)
    {
        Z = z;
    }
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        A class inherits the members of its base class. Inheritance means that a class implicitly
                        contains almost all members of its base class. A class doesn't inherit the instance and static
                        constructors, and the finalizer. A derived class can add new members to those members it
                        inherits, but it can't remove the definition of an inherited member. In the previous example,
                        <code>Point3D</code> inherits the <code>X</code> and <code>Y</code> members from
                        <code>Point</code>, and every <code>Point3D</code> instance contains three properties,
                        <code>X</code>, <code>Y</code>, and <code>Z</code>.
                    </p>
                    <p>
                        An implicit conversion exists from a class type to any of its base class types. A variable of a
                        class type can reference an instance of that class or an instance of any derived class. For
                        example, given the previous class declarations, a variable of type <code>Point</code> can
                        reference either a <code>Point</code> or a <code>Point3D</code>:
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
Point a = <span class="code-keyword">new</span> Point(10, 20);
Point b = <span class="code-keyword">new</span> Point3D(10, 20, 30);
                            </code>
                        </pre>
                    </div>
                </article>
            </section>

            <section id="structs">
                <header>
                    <h3>Structs</h3>
                </header>
                <article>
                    <p>
                        Classes define types that support inheritance and polymorphism. They enable you to create
                        sophisticated behaviors based on hierarchies of derived classes. By contrast, <a
                            href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/struct"><em><strong>struct</strong></em></a>
                        types are simpler types whose primary purpose is to store data values. Structs can't declare a
                        base type; they implicitly derive from <a
                            href="https://docs.microsoft.com/en-us/dotnet/api/system.valuetype">System.ValueType</a>.
                        You can't derive other <code>struct</code> types from a <code>struct</code> type. They're
                        implicitly sealed.
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">public struct</span> Point
{
    <span class="code-keyword">public double</span> X { <span class="code-keyword">get</span>; }
    <span class="code-keyword">public double</span> Y { <span class="code-keyword">get</span>; }

    <span class="code-keyword">public</span> <span class="code-title">Point</span>(<span class="code-keyword">double</span> x, <span class="code-keyword">double</span> y) => (X, Y) = (x, y);
}
                            </code>
                        </pre>
                    </div>
                </article>
            </section>

            <section id="interfaces">
                <header>
                    <h3>Interfaces</h3>
                </header>
                <article>
                    <p>
                        An <a
                            href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/interfaces/"><em><strong>interface</strong></em></a>
                        defines a contract that can be implemented by classes and structs. An interface can contain
                        methods, properties, events, and indexers. An interface typically doesn't provide
                        implementations of the members it defines—it merely specifies the members that must be supplied
                        by classes or structs that implement the interface.
                    </p>
                    <p>
                        Interfaces may employ <em><strong>multiple inheritance</strong></em>. In the following example,
                        the interface <code>IComboBox</code> inherits from both <code>ITextBox</code> and
                        <code>IListBox</code>.
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">interface</span> <span class="code-title">IControl</span>
{
    <span class="code-keyword">void</span> <span class="code-title">Paint</span>();
}

<span class="code-keyword">interface</span> <span class="code-title">ITextBox</span> : <span class="code-title">IControl</span>
{
    <span class="code-keyword">void</span> <span class="code-title">SetText</span>(<span class="code-keyword">string</span> text);
}

<span class="code-keyword">interface</span> <span class="code-title">IListBox</span> : <span class="code-title">IControl</span>
{
    <span class="code-keyword">void</span> <span class="code-title">SetItems</span>(<span class="code-keyword">string</span>[] items);
}

<span class="code-keyword">interface</span> <span class="code-title">IComboBox</span> : <span class="code-title">ITextBox</span>, <span class="code-title">IListBox</span> { }
                            </code>
                        </pre>
                    </div>
                    <p>
                        Classes and structs can implement multiple interfaces. In the following example, the class
                        <code>EditBox</code> implements both <code>IControl</code> and <code>IDataBound</code>.
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">interface</span> <span class="code-title">IDataBound</span>
{
    <span class="code-keyword">void</span> <span class="code-title">Bind</span>(Binder b);
}

<span class="code-keyword">public class</span> <span class="code-title">EditBox</span> : <span class="code-title">IControl</span>, <span class="code-title">IDataBound</span>
{
    <span class="code-keyword">public void</span> <span class="code-title">Paint</span>() { }
    <span class="code-keyword">public void</span> <span class="code-title">Bind</span>(Binder b) { }    
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        When a class or struct implements a particular interface, instances of that class or struct can
                        be implicitly converted to that interface type. For example
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
EditBox editBox = <span class="code-keyword">new</span> EditBox();
IControl control = editBox;
IDataBound dataBound = editBox;
                            </code>
                        </pre>
                    </div>
                </article>
            </section>

            <section id="enums">
                <header>
                    <h3>Enums</h3>
                </header>
                <article>
                    <p>
                        An <a
                            href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum"><em><strong>Enum</strong></em></a>
                        type defines a set of constant values. The following <code>enum</code> declares constants that
                        define different root vegetables:
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">public enum</span> SomeRootVegetables
{
    HorseRadish,
    Radish,
    Turnip
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        You can also define an <code>enum</code> to be used in combination as flags. The following
                        declaration declares a set of flags for the four seasons. Any combination of the seasons may be
                        applied, including an <code>All</code> value that includes all seasons:
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
[<span class="code-title">Flags</span>]
<span class="code-keyword">public enum</span> Seasons
{
    None = 0,,
    Summer = 1,
    Autumn = 2,
    Winter = 4,
    Spring = 8,
    All = Summer | Autumn | Winter | Spring
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        The following example shows declarations of both the preceding enums:
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">var</span> turnip = SomeRootVegetables.Turnip;

<span class="code-keyword">var</span> spring = Seasons.Spring;
<span class="code-keyword">var</span> startingOnEquinox = Seasons.Spring | Seasons.Autumn;
<span class="code-keyword">var</span> theYear = Seasons.All;
                            </code>
                        </pre>
                    </div>
                </article>
            </section>

            <section id="nullable types">
                <header>
                    <h3>Nullable Types</h3>
                </header>
                <article>
                    <p>
                        Variables of any type may be declared as <em><strong>non-nullable</strong></em> or
                        <em><strong>nullable</strong></em>. A nullable variable can hold an additional <code>null</code>
                        value, indicating no value. Nullable Value types (structs or enums) are represented by <a
                            href="https://docs.microsoft.com/en-us/dotnet/api/system.nullable-1">System.Nullable&lt;T&gt;</a>.
                        Non-nullable and Nullable Reference types are both represented by the underlying reference type.
                        The distinction is represented by metadata read by the compiler and some libraries. The compiler
                        provides warnings when nullable references are dereferenced without first checking their value
                        against <code>null</code>. The compiler also provides warnings when non-nullable references are
                        assigned a value that may be <code>null</code>. The following example declares a
                        <em><strong>nullable int</strong></em>, initializing it to <code>null</code>. Then, it sets the
                        value to <code>5</code>. It demonstrates the same concept with a <em><strong>nullable
                                string</strong></em>. For more information, see <a
                            href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-value-types">nullable
                            value types</a> and <a
                            href="https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references">nullable reference
                            types</a>.
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">int</span>? optionalInt = <span class="code-keyword">default</span>;
optionalInt = 5;
<span class="code-keyword">string</span>? optionalText = <span class="code-keyword">default</span>;
optionalText = <span class="code-string">"Hello World."</span>;
                            </code>
                        </pre>
                    </div>
                </article>
            </section>

            <section id="tuples">
                <header>
                    <h3>Tuples</h3>
                </header>
                <article>
                    <p>
                        C# supports <a
                            href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-tuples"><em><strong>tuples</strong></em></a>,
                        which provides concise syntax to group multiple data elements in a lightweight data structure.
                        You instantiate a tuple by declaring the types and names of the members between <code>(</code>
                        and <code>)</code>, as shown in the following example:
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
(<span class="code-keyword">double</span> Sum, <span class="code-keyword">int</span> Count) t2 = (4.5, 3);
Console.WriteLine(<span class="code-string">$"Sum of </span>{t2.Count} <span class="code-string">elements is</span> {t2.Sum}<span class="code-string">."</span>);
<span class="code-comment">// Output:</span>
<span class="code-comment">// Sum of 3 elements is 4.5.</span>
                            </code>
                        </pre>
                    </div>
                    <p>
                        Tuples provide an alternative for data structure with multiple members, without using the
                        building blocks described in the next article.
                    </p>
                </article>
            </section>

        </section>

        <section id="Program_Building_Blocks" class="main-section">
            <header>
                <h2>Program Building Blocks</h2>
            </header>
            <article>
                <p>
                    The types described in the previous article are built using these building blocks: <a
                        href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/members"><em><strong>members</strong></em></a>,
                    <a
                        href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/"><em><strong>expressions</strong></em>,
                        and <em><strong>statements</strong></em></a>.
                </p>
            </article>

            <section id="members">
                <header>
                    <h3>Members</h3>
                </header>
                <article>
                    <p>
                        The members of a <code>class</code> are either <em><strong>static members</strong></em> or
                        <em><strong>instance members</strong></em>. Static members belong to classes, and instance
                        members belong to objects (instances of classes).
                    </p>
                    <p>
                        The following list provides an overview of the kinds of members a class can contain.
                    </p>
                    <ul>
                        <li><strong>Constants</strong>: Constant values associated with the class</li>
                        <li><strong>Fields</strong>: Variables that are associated of the class</li>
                        <li><strong>Methods</strong>: Actions that can be performed by the class</li>
                        <li><strong>Properties</strong>: Actions associated with reading and writing named properties of
                            the class</li>
                        <li><strong>Indexers</strong>: Actions associated with indexing instances of the class like an
                            array</li>
                        <li><strong>Events</strong>: Notifications that can be generated by the class</li>
                        <li><strong>Operators</strong>: Conversions and expression operators supported by the class</li>
                        <li><strong>Constructors</strong>: Actions required to initialize instances of the class or the
                            class itself</li>
                        <li><strong>Finalizers</strong>: Actions performed before instances of the class are permanently
                            discarded</li>
                        <li><strong>Types</strong>: Nested types declared by the class</li>
                    </ul>
                </article>
            </section>

            <section id="accessibility">
                <header>
                    <h3>Accessibility</h3>
                </header>
                <article>
                    <p>
                        Each member of a class has an associated accessibility, which controls the regions of program
                        text that can access the member. There are six possible forms of accessibility. The access
                        modifiers are summarized below.
                    </p>
                    <ul>
                        <li><code>public</code>: Access isn't limited.</li>
                        <li><code>private</code>: Access is limited to this class.</li>
                        <li><code>protected</code>: Access is limited to this class or classes derived from this class.
                        </li>
                        <li><code>internal</code>: Access is limited to the current assembly (<code>.exe</code> or
                            <code>.dll</code>).</li>
                        <li><code>protected internal</code>: ess is limited to this class, classes derived from this
                            class, or classes within the same assembly.</li>
                        <li><code>private protected</code>: Access is limited to this class or classes derived from this
                            type within the same assembly.</li>
                    </ul>
                </article>
            </section>

            <section id="fields">
                <header>
                    <h3>Fields</h3>
                </header>
                <article>
                    <p>
                        A <em>field</em> is a variable that is associated with a class or with an instance of a class.
                    </p>
                    <p>
                        A field declared with the static modifier defines a static field. A static field identifies
                        exactly one storage location. No matter how many instances of a class are created, there's only
                        ever one copy of a static field.
                    </p>
                    <p>
                        A field declared without the static modifier defines an instance field. Every instance of a
                        class contains a separate copy of all the instance fields of that class.
                    </p>
                    <p>
                        In the following example, each instance of the <code>Color</code> class has a separate copy of
                        the <code>r</code>, <code>g</code>, and <code>b</code> instance fields, but there's only one
                        copy of the <code>Black</code>, <code>White</code>, <code>Red</code>, <code>Green</code>, and
                        <code>Blue</code> static fields:
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">public class</span> <span class="code-title">Color</span>
{
    <span class="code-keyword">public static readonly</span> Color Black = <span class="code-keyword">new</span> Color(0, 0, 0);
    <span class="code-keyword">public static readonly</span> Color White = <span class="code-keyword">new</span> Color(255, 255, 255);
    <span class="code-keyword">public static readonly</span> Color Red = <span class="code-keyword">new</span> Color(255, 0, 0);
    <span class="code-keyword">public static readonly</span> Color Green = <span class="code-keyword">new</span> Color(0, 255, 0);
    <span class="code-keyword">public static readonly</span> Color Blue = <span class="code-keyword">new</span> Color(0, 0, 255);

    <span class="code-keyword">public byte</span> R { <span class="code-keyword">get</span>; }
    <span class="code-keyword">public byte</span> G { <span class="code-keyword">get</span>; }
    <span class="code-keyword">public byte</span> B { <span class="code-keyword">get</span>; }

    <span class="code-keyword">public</span> <span class="code-title">Color</span>(<span class="code-keyword">byte</span> r, <span class="code-keyword">byte</span> g, <span class="code-keyword">byte</span> b)
    {
        R = r;
        G = g;
        B = b;
    }
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        As shown in the previous example, <em>read-only fields</em> may be declared with a
                        <code>readonly</code> modifier. Assignment to a read-only field can only occur as part of the
                        field’s declaration or in a constructor in the same class.
                    </p>
                </article>
            </section>

            <section id="methods">
                <header>
                    <h3>Methods</h3>
                </header>
                <article>
                    <p>
                        A <em>method</em> is a member that implements a computation or action that can be performed by
                        an object or class. <em>Static methods</em> are accessed through the class. <em>Instance
                            methods</em> are accessed through instances of the class.
                    </p>
                    <p>
                        Methods may have a list of <em>parameters</em>, which represent values or variable references
                        passed to the method. Methods have a <em>return type</em>, which specifies the type of the value
                        computed and returned by the method. A method’s return type is <code>void</code> if it doesn't
                        return a value.
                    </p>
                    <p>
                        Like types, methods may also have a set of type parameters, for which type arguments must be
                        specified when the method is called. Unlike types, the type arguments can often be inferred from
                        the arguments of a method call and need not be explicitly given.
                    </p>
                    <p>
                        The <em>signature</em> of a method must be unique in the class in which the method is declared.
                        The signature of a method consists of the name of the method, the number of type parameters, and
                        the number, modifiers, and types of its parameters. The signature of a method doesn't include
                        the return type.
                    </p>
                    <p>
                        When a method body is a single expression, the method can be defined using a compact expression
                        format, as shown in the following example:
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">public override</span> <span class="code-title">ToString</span>() => <span class="code-string">"This is an object"</span>;
                            </code>
                        </pre>
                    </div>
                </article>
            </section>

            <section id="parameters">
                <header>
                    <h3>Parameters</h3>
                </header>
                <article>
                    <p>
                        Parameters are used to pass values or variable references to methods. The parameters of a method
                        get their actual values from the <em>arguments</em> that are specified when the method is
                        invoked. There are four kinds of parameters: value parameters, reference parameters, output
                        parameters, and parameter arrays.
                    </p>
                    <p>
                        A <em>value parameter</em> is used for passing input arguments. A value parameter corresponds to
                        a local variable that gets its initial value from the argument that was passed for the
                        parameter. Modifications to a value parameter don't affect the argument that was passed for the
                        parameter.
                    </p>
                    <p>
                        Value parameters can be optional, by specifying a default value so that corresponding arguments
                        can be omitted.
                    </p>
                    <p>
                        A <em>reference parameter</em> is used for passing arguments by reference. The argument passed
                        for a reference parameter must be a variable with a definite value. During execution of the
                        method, the reference parameter represents the same storage location as the argument variable. A
                        reference parameter is declared with the ref modifier. The following example shows the use of
                        <code>ref</code> parameters.
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">static void</span> <span class="code-title">Swap</span>(<span class="code-keyword">ref int</span> x, <span class="code-keyword">ref int</span> y)
{
    <span class="code-keyword">int</span> temp = x;
    x = y;
    y = temp;
}

<span class="code-keyword">public static void</span> <span class="code-title">SwapExample</span>()
{
    <span class="code-keyword">int</span> i = 1, j = 2;
    Swap(<span class="code-keyword">ref</span> i , <span class="code-keyword">ref</span> j);
    Console.WriteLine(<span class="code-string">$"</span>{i} {j}<span class="code-string">"</span>);    <span class="code-comment">// "2 1"</span>
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        An <em>output parameter</em> is used for passing arguments by reference. It's similar to a
                        reference parameter, except that it doesn't require that you explicitly assign a value to the
                        caller-provided argument. An output parameter is declared with the <code>out</code> modifier.
                        The following example shows the use of <code>out</code> parameters using the syntax introduced
                        in C# 7.
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">static void</span> <span class="code-title">Divide</span>(<span class="code-keyword">int</span> x, <span class="code-keyword">int</span> y, <span class="code-keyword">out int</span> result, <span class="code-keyword">out int</span> remainder)
{
    result = x / y;
    remainder = x % y;
}

<span class="code-keyword">public static void</span> <span class="code-title">OutUsage</span>()
{
    Divide(10, 3, <span class="code-keyword">out int</span> res, <span class="code-keyword">out int</span> rem);
    Console.WriteLine(<span class="code-string">$"</span>{res} {rem}<span class="code-string">"</span>);    <span class="code-comment">// "3 1"</span>
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        A <em>parameter array</em> permits a variable number of arguments to be passed to a method. A
                        parameter array is declared with the <code>params</code> modifier. Only the last parameter of a
                        method can be a parameter array, and the type of a parameter array must be a single-dimensional
                        array type. The <code>Write</code> and <code>WriteLine</code> methods of the <a
                            href="https://docs.microsoft.com/en-us/dotnet/api/system.console">System.Console</a> class
                        are good examples of parameter array usage. They're declared as follows.
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">public class</span> <span class="code-title">Console</span>
{
    <span class="code-keyword">public static void</span> <span class="code-title">Write</span>(<span class="code-keyword">string</span> fmt, <span class="code-keyword">params object</span>[] args) { }
    <span class="code-keyword">public static void</span> <span class="code-title">WriteLine</span>(<span class="code-keyword">string</span> fmt, <span class="code-keyword">params object</span>[] args) { }
    <span class="code-comment">// ...</span>
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        Within a method that uses a parameter array, the parameter array behaves exactly like a regular
                        parameter of an array type. However, in an invocation of a method with a parameter array, it's
                        possible to pass either a single argument of the parameter array type or any number of arguments
                        of the element type of the parameter array. In the latter case, an array instance is
                        automatically created and initialized with the given arguments. This example
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">int</span> x, y, z;
x = 3;
y = 4;
z = 5;
Console.WriteLine(<span class="code-string">"x={0} y={1} z={2}"</span>, x, y, z);
                            </code>
                        </pre>
                    </div>
                    <p>
                        is equivalent to writing the following.
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">int</span> x = 3, y = 4, z = 5;

<span class="code-keyword">string</span>s = <span class="code-string">"x={0} y={1} z={2}"</span>;
<span class="code-keyword">object</span>[] args = <span class="code-keyword">new object</span>[3];
args[0] = x;
args[1] = y;
args[2] = z;
Console.WriteLine(s, args);
                            </code>
                        </pre>
                    </div>
                </article>
            </section>

            <section id="method-body-and-local-variables">
                <header>
                    <h3>Method Body and Local Variables</h3>
                </header>
                <article>
                    <p>
                        A method’s body specifies the statements to execute when the method is invoked.
                    </p>
                    <p>
                        A method body can declare variables that are specific to the invocation of the method. Such
                        variables are called <em>local variables</em>. A local variable declaration specifies a type
                        name, a variable name, and possibly an initial value. The following example declares a local
                        variable <code>i</code> with an initial value of zero and a local variable <code>j</code> with
                        no initial value.
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">class</span> <span class="code-title">Squares</span>
{
    <span class="code-keyword">public static void</span> <span class="code-title">WriteSquares</span>()
    {
        <span class="code-keyword">int</span> i = 0;
        <span class="code-keyword">int</span> j;
        <span class="code-keyword">while</span> (i &lt; 10)
        {
            j = i * i;
            Console.WriteLine(<span class="code-string">$"</span>{i} <span class="code-string">x</span> {i} = {j}<span class="code-string">"</span>);
            i = i + 1;
        }
    }
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        C# requires a local variable to be <em>definitely assigned</em> before its value can be
                        obtained. For example, if the declaration of the previous <code>i</code> didn't include an
                        initial value, the compiler would report an error for the later usages of <code>i</code> because
                        <code>i</code> wouldn't be definitely assigned at those points in the program.
                    </p>
                    <p>
                        A method can use <code>return</code> statements to return control to its caller. In a method
                        returning <code>void</code>, <code>return</code> statements can't specify an expression. In a
                        method returning non-void, <code>return</code> statements must include an expression that
                        computes the return value.
                    </p>
                </article>
            </section>

            <section id="static-and-instance-methods">
                <header>
                    <h3>Static and Instance Methods</h3>
                </header>
                <article>
                    <p>
                        A method declared with a <code>static</code> modifier is a <em>static method</em>. A static
                        method doesn't operate on a specific instance and can only directly access static members.
                    </p>
                    <p>
                        A method declared without a <code>static</code> modifier is an <em>instance method</em>. An
                        instance method operates on a specific instance and can access both static and instance members.
                        The instance on which an instance method was invoked can be explicitly accessed as
                        <code>this</code>. It's an error to refer to <code>this</code> in a static method.
                    </p>
                    <p>
                        The following <code>Entity</code> class has both static and instance members.
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">class</span> <span class="code-title">Entity</span>
{
    <span class="code-keyword">static int</span> s_nextSerialNo;
    <span class="code-keyword">int</span> _serialNo;

    <span class="code-keyword">public</span> <span class="code-title">Entity</span>()
    {
        _serialNo = s_nextSerialNo++;
    }

    <span class="code-keyword">public int</span> <span class="code-title">GetSerialNo</span>()
    {
        <span class="code-keyword">return</span> _serialNo;
    }

    <span class="code-keyword">public static int</span> <span class="code-title">GetNextSerialNo</span>()
    {
        <span class="code-keyword">return</span> s_nextSerialNo;
    }

    <span class="code-keyword">public static void</span> <span class="code-title">SetNextSerialNo</span>(<span class="code-keyword">int value</span>)
    {
        s_nextSerialNo = <span class="code-keyword">value</span>
    }
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        Each <code>Entity</code> instance contains a serial number (and presumably some other
                        information that isn't shown here). The <code>Entity</code> constructor (which is like an
                        instance method) initializes the new instance with the next available serial number. Because the
                        constructor is an instance member, it's permitted to access both the <code>_serialNo</code>
                        instance field and the <code>s_nextSerialNo</code> static field.
                    </p>
                    <p>
                        The <code>GetNextSerialNo</code> and <code>SetNextSerialNo</code> static methods can access the
                        <code>s_nextSerialNo</code> static field, but it would be an error for them to directly access
                        the <code>_serialNo</code> instance field.
                    </p>
                    <p>
                        The following example shows the use of the <code>Entity</code> class.
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
Entity.SetNextSerialNo(1000);
Entity e1 = <span class="code-keyword">new</span> Entity();
Entity e2 = <span class="code-keyword">new</span> Entity();
Console.WriteLine(e1.GetSerialNo());            <span class="code-comment">// Outputs "1000"</span>
Console.WriteLine(e2.GetSerialNo());            <span class="code-comment">// Outputs "1001"</span>
Console.WriteLine(Entity.GetNextSerialNo());    <span class="code-comment">// Outputs "1002"</span>
                            </code>
                        </pre>
                    </div>
                    <p>
                        The <code>SetNextSerialNo</code> and <code>GetNextSerialNo</code> static methods are invoked on
                        the class whereas the <code>GetSerialNo</code> instance method is invoked on instances of the
                        class.
                    </p>
                </article>
            </section>

            <section id="virtual-override-and-abstract-methods">
                <header>
                    <h3>Virtual, Override and Abstract Methods</h3>
                </header>
                <article>
                    <p>
                        When an instance method declaration includes a <code>virtual</code> modifier, the method is said
                        to be a <em>virtual method</em>. When no virtual modifier is present, the method is said to be a
                        <em>nonvirtual method</em>.
                    </p>
                    <p>
                        When a virtual method is invoked, the <em>run-time type</em> of the instance for which that
                        invocation takes place determines the actual method implementation to invoke. In a nonvirtual
                        method invocation, the <em>compile-time type</em> of the instance is the determining factor.
                    </p>
                    <p>
                        A virtual method can be <em>overridden</em> in a derived class. When an instance method
                        declaration includes an override modifier, the method overrides an inherited virtual method with
                        the same signature. Aa virtual method declaration introduces a new method. An override method
                        declaration specializes an existing inherited virtual method by providing a new implementation
                        of that method.
                    </p>
                    <p>
                        An <em>abstract method</em> is a virtual method with no implementation. An abstract method is
                        declared with the <code>abstract</code> modifier and is permitted only in an abstract class. An
                        abstract method must be overridden in every non-abstract derived class.
                    </p>
                    <p>
                        The following example declares an abstract class, <code>Expression</code>, which represents an
                        expression tree node, and three derived classes, <code>Constant</code>,
                        <code>VariableReference</code>, and <code>Operation</code>, which implement expression tree
                        nodes for constants, variable references, and arithmetic operations. (This example is similar
                        to, but not related to the expression tree types).
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">public abstract class</span> <span class="code-title">Expression</span>
{
    <span class="code-keyword">public abstract double</span> <span class="code-title">Evaluate</span>(Dictionary&lt;<span class="code-keyword">string</span>, <span class="code-keyword">object</span>&gt; vars);
}

<span class="code-keyword">public class</span> <span class="code-title">Constant</span> : <span class="code-title">Expression</span>
{
    <span class="code-keyword">double</span> _value;

    <span class="code-keyword">public</span> <span class="code-title">Constant</span>(<span class="code-keyword">double value</span>)
    {
        _value = <span class="code-keyword">value</span>;
    }

    <span class="code-keyword">public override double</span> <span class="code-title">Evaluate</span>(Dictionary&lt;<span class="code-keyword">string</span>, <span class="code-keyword">object</span>&gt; vars)
    {
        <span class="code-keyword">return</span> _value;
    }
}

<span class="code-keyword">public class</span> <span class="code-title">VariableReference</span> : <span class="code-title">Expression</span>
{
    <span class="code-keyword">string</span> _name;

    <span class="code-keyword">public</span> <span class="code-title">VariableReference</span>(<span class="code-keyword">string</span> name)
    {
        _name = name;
    }

    <span class="code-keyword">public override double</span> <span class="code-title">Evaluate</span>(Dictionary&lt;<span class="code-keyword">string</span>, <span class="code-keyword">object</span>&gt; vars)
    {
        <span class="code-keyword">object value</span> = vars[_name] ?? <span class="code-keyword">throw new</span> Exception(<span class="code-string">$"Unknown variable:</span> {_name}<span class="code-string">"</span>);
        <span class="code-keyword">return</span> Convert.ToDouble(<span class="code-keyword">value</span>);
    }
}

<span class="code-keyword">public class</span> <span class="code-title">Operation</span> : <span class="code-title">Expression</span>
{
    Expression _left;
    <span class="code-keyword">char</span> _op;
    Expression _right;

    <span class="code-keyword">public</span> <span class="code-title">Operation</span>(Expression left, <span class="code-keyword">char</span> op, Expression right)
    {
        _left = left;
        _op = op;
        _right = right;
    }

    <span class="code-keyword">public override double</span> <span class="code-title">Evaluate</span>(Dictionary&lt;<span class="code-keyword">string</span>, <span class="code-keyword">object</span>&gt; vars)
    {
        <span class="code-keyword">double</span> x = left.Evaluate(vars);
        <span class="code-keyword">double</span> y = right.Evaluate(vars);
        <span class="code-keyword">switch</span> (_op)
        {
            <span class="code-keyword">case</span> <span class="code-string">'+'</span>: <span class="code-keyword">return</span> x + y;
            <span class="code-keyword">case</span> <span class="code-string">'-'</span>: <span class="code-keyword">return</span> x - y;
            <span class="code-keyword">case</span> <span class="code-string">'*'</span>: <span class="code-keyword">return</span> x * y;
            <span class="code-keyword">case</span> <span class="code-string">'/'</span>: <span class="code-keyword">return</span> x / y;

            <span class="code-keyword">default</span>: <span class="code-keyword">throw new</span> Exception(<span class="code-string">"Unknown operator"</span>);
        }
    }
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        The previous four classes can be used to model arithmetic expressions. For example, using
                        instances of these classes, the expression <code>x + 3</code> can be represented as follows.
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
Expression e = <span class="code-keyword">new</span> Operation(
    <span class="code-keyword">new</span> VariableReference(<span class="code-string">"x"</span>,
    <span class="code-string">'+'</span>,
    <span class="code-keyword">new</span> Constant(3));
                            </code>
                        </pre>
                    </div>
                    <p>
                        The <code>Evaluate</code> method of an <code>Expression</code> instance is invoked to evaluate
                        the given expression and produce a <code>double</code> value. The method takes a
                        <code>Dictionary</code> argument that contains variable names (as keys of the entries) and
                        values (as values of the entries). Because <code>Evaluate</code> is an abstract method,
                        non-abstract classes derived from <code>Expression</code> must override <code>Evaluate</code>.
                    </p>
                    <p>
                        A <code>Constant</code>'s implementation of <code>Evaluate</code> simply returns the stored
                        constant. A <code>VariableReference</code>'s implementation looks up the variable name in the
                        dictionary and returns the resulting value. An <code>Operation</code>'s implementation first
                        evaluates the left and right operands (by recursively invoking their <code>Evaluate</code>
                        methods) and then performs the given arithmetic operation.
                    </p>
                    <p>
                        The following program uses the <code>Expression</code> classes to evaluate the expression
                        <code>x * (y + 2)</code> for different values of <code>x</code> and <code>y</code>.
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
Expression e = <span class="code-keyword">new</span> Operation(
    <span class="code-keyword">new</span> VariableReference(<span class="code-string">"x"</span>),
    <span class="code-string">'*'</span>,
    <span class="code-keyword">new</span> Operation(
        <span class="code-keyword">new</span> VariableReference(<span class="code-string">"y"</span>),
        <span class="code-string">'+'</span>,
        <span class="code-keyword">new</span> Constant(2)
    )
);
Dictionary&lt;<span class="code-keyword">string</span>, <span class="code-keyword">object</span>&gt; vars = <span class="code-keyword">new</span> Dictionary&lt;<span class="code-keyword">string</span>, <span class="code-keyword">object</span>&gt;();
vars[<span class="code-string">"x"</span>] = 3;
vars[<span class="code-string">"y"</span>] = 5;
Console.WriteLine(e.Evaluate(vars));    <span class="code-comment">// "21"</span>
vars[<span class="code-string">"x"</span>] = 1.5;
vars[<span class="code-string">"y"</span>] = 9;
Console.WriteLine(e.Evaluate(vars));    <span class="code-comment">// "16.5</span>
                            </code>
                        </pre>
                    </div>
                </article>
            </section>

            <section id="method-overloading">
                <header>
                    <h3>Method Overloading</h3>
                </header>
                <article>
                    <p>
                        Method <em>overloading</em> permits multiple methods in the same class to have the same name as
                        long as they have unique signatures. When compiling an invocation of an overloaded method, the
                        compiler uses <em>overload resolution</em> to determine the specific method to invoke. Overload
                        resolution finds the one method that best matches the arguments. If no single best match can be
                        found, an error is reported. The following example shows overload resolution in effect. The
                        comment for each invocation in the <code>UsageExample</code> method shows which method is
                        invoked.
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">class</span> <span class="code-title">OverloadingExample</span>
{
    <span class="code-keyword">static void</span> F() => Console.WriteLine(<span class="code-string">"F()"</span>);
    <span class="code-keyword">static void</span> F(<span class="code-keyword">object</span> x) => Console.WriteLine(<span class="code-string">"F(object)"</span>);
    <span class="code-keyword">static void</span> F(<span class="code-keyword">int</span> x) => Console.WriteLine(<span class="code-string">"F(int)"</span>);
    <span class="code-keyword">static void</span> F(<span class="code-keyword">double</span> x) => Console.WriteLine(<span class="code-string">"F(double)"</span>);
    <span class="code-keyword">static void</span> F&lt;T&gt;(T x) => Console.WriteLine(<span class="code-string">"F&lt;T&gt;(T)"</span>);
    <span class="code-keyword">static void</span> F(<span class="code-keyword">double</span> x, <span class="code-keyword">double</span> y) => Console.WriteLine(<span class="code-string">"F(double, double)"</span>);

    <span class="code-keyword">public static void</span> <span class="code-title">UsageExample</span>()
    {
        F();                <span class="code-comment">// Invokes F()</span>
        F(1);               <span class="code-comment">// Invokes F(int)</span>
        F(1.0);             <span class="code-comment">// Invokes F(double)</span>
        F(<span class="code-string">"abc"</span>);           <span class="code-comment">// Invokes F&lt;string&gt;(string)</span>
        F((double)1);       <span class="code-comment">// Invokes F(double)</span>
        F((object)1);       <span class="code-comment">// Invokes F(object)</span>
        F&lt;int&gt;(1);          <span class="code-comment">// Invokes F&lt;int&gt;(int)</span>
        F(1, 1);            <span class="code-comment">// Invokes F(double, double)</span>
    }
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        As shown by the example, a particular method can always be selected by explicitly casting the
                        arguments to the exact parameter types and type arguments.
                    </p>
                </article>
            </section>

            <section id="other-function-methods">
                <header>
                    <h3>Other Function Members</h3>
                </header>
                <article>
                    <p>
                        Members that contain executable code are collectively known as the <em>function members</em> of
                        a class. The preceding section describes methods, which are the primary types of function
                        members. This section describes the other kinds of function members supported by C#:
                        constructors, properties, indexers, events, operators, and finalizers.
                    </p>
                    <p>
                        The following example shows a generic class called <code>MyList&lt;T&gt;</code>, which
                        implements a growable list of objects. The class contains several examples of the most common
                        kinds of function members.
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">public class</span> <span class="code-title">MyList</span>&lt;<span class="code-title">T</span>&gt;
{
    <span class="code-keyword">const int</span> DefaultCapacity = 4;

    T[] _items;
    <span class="code-keyword">int</span> _count;

    <span class="code-keyword">public</span> <span class="code-title">MyList</span>(<span class="code-keyword">int</span> capacity = DefaultCapacity)
    {
        _items = <span class="code-keyword">new</span> T[capacity];
    }

    <span class="code-keyword">public int</span> Count => _count;

    <span class="code-keyword">public int</span> Capacity
    {
        <span class="code-keyword">get</span> => _items.Length;
        <span class="code-keyword">set</span>
        {
            <span class="code-keyword">if</span> (<span class="code-keyword">value</span> &lt; _count) <span class="code-keyword">value</span> = _count;
            <span class="code-keyword">if</span> (<span class="code-keyword">value</span> != _items.Length)
            {
                T[] newItems = <span class="code-keyword">new</span> T[<span class="code-keyword">value</span>];
                Array.Copy(_items, 0, newItems, 0, _count);
                _items = newItems;
            }
        }
    }

    <span class="code-keyword">public</span> T <span class="code-keyword">this</span>[<span class="code-keyword">int</span> index]
    {
        <span class="code-keyword">get</span> => _items[index];
        <span class="code-keyword">set</span>
        {
            _items[index] = <span class="code-keyword">value</span>;
            OnChanged();
        }
    }

    <span class="code-keyword">public void</span> <span class="code-title">Add</span>(T item)
    {
        <span class="code-keyword">if</span> (_count == Capacity) Capacity = _count * 2;
        _items[_count] = item;
        _count++;
        OnChanged();
    }
    <span class="code-keyword">protected virtual void</span> <span class="code-title">OnChanged</span>() =>
        Changed?.Invoke(<span class="code-keyword">this</span>, EventArgs.Empty);

    <span class="code-keyword">public override bool</span> <span class="code-title">Equals</span>(<span class="code-keyword">object</span> other) =>
        Equals(<span class="code-keyword">this</span>, other <span class="code-keyword">as</span> MyList&lt;T&gt;);

    <span class="code-keyword">static bool</span> <span class="code-title">Equals</span>(MyList&lt;T&gt; a, MyList&lt;T&gt; b)
    {
        <span class="code-keyword">if</span> (Object.ReferenceEquals(a, <span class="code-title">null</span>)) <span class="code-keyword">return</span> Object.ReferenceEquals(b, <span class="code-title">null</span>);
        <span class="code-keyword">if</span> (Object.ReferenceEquals(b, <span class="code-title">null</span>) || a._count != b._count)
            <span class="code-keyword">return</span> <span class="code-title">false</span>;
        <span class="code-keyword">for</span> (<span class="code-keyword">int</span> i = 0; i &lt; a._count; i++)
        {
            <span class="code-keyword">if</span> (!<span class="code-keyword">object</span>.Equals(a._items[i], b._items[i]))
            {
                <span class="code-keyword">return</span> <span class="code-title">false</span>;
            }
        }
        <span class="code-keyword">return</span> <span class="code-title">true</span>;
    }

    <span class="code-keyword">public event</span> EventHandler Changed;

    <span class="code-keyword">public static bool operator</span> ==(MyList&lt;T&gt; a, MyList&lt;T&gt; b) =>
        Equals(a, b);
    
    <span class="code-keyword">public static bool operator</span> !=(MyList&lt;T&gt; a, MyList&lt;T&gt; b) =>
        !Equals(a, b);
}
                            </code>
                        </pre>
                    </div>
                </article>
            </section>

            <section id="constructors">
                <header>
                    <h3>Constructors</h3>
                </header>
                <article>
                    <p>
                        C# supports both instance and static constructors. An <em>instance constructor</em> is a member
                        that implements the actions required to initialize an instance of a class. A <em>static
                            constructor</em> is a member that implements the actions required to initialize a class
                        itself when it's first loaded.
                    </p>
                    <p>
                        A constructor is declared like a method with no return type and the same name as the containing
                        class. If a constructor declaration includes a <code>static</code> modifier, it declares a
                        static constructor. Otherwise, it declares an instance constructor.
                    </p>
                    <p>
                        Instance constructors can be overloaded and can have optional parameters. For example, the
                        <code>MyList&lt;T&gt;</code> class declares one instance constructor with a single optional
                        <code>int</code> parameter. Instance constructors are invoked using the <code>new</code>
                        operator. The following statements allocate two <code>MyList&lt;string&gt;</code> instances
                        using the constructor of the <code>MyList</code> class with and without the optional argument.
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
MyList&lt;<span class="code-keyword">string</span>&gt; list1 = <span class="code-keyword">new</span> MyList&lt;<span class="code-keyword">string</span>&gt;();
MyList&lt;<span class="code-keyword">string</span>&gt; list2 = <span class="code-keyword">new</span> MyList&lt;<span class="code-keyword">string</span>&gt;(10);
                            </code>
                        </pre>
                    </div>
                    <p>
                        Unlike other members, instance constructors aren't inherited. A class has no instance
                        constructors other than those constructors actually declared in the class. If no instance
                        constructor is supplied for a class, then an empty one with no parameters is automatically
                        provided.
                    </p>
                </article>
            </section>

            <section id="properties">
                <header>
                    <h3>Properties</h3>
                </header>
                <article>
                    <p>
                        <em>Properties</em> are a natural extension of fields. Both are named members with associated
                        types, and the syntax for accessing fields and properties is the same. However, unlike fields,
                        properties don't denote storage locations. Instead, properties have <em>accessors</em> that
                        specify the statements executed when their values are read or written.
                    </p>
                    <p>
                        A property is declared like a field, except that the declaration ends with a get accessor or a
                        set accessor written between the delimiters <code>{</code> and <code>}</code> instead of ending
                        in a semicolon. A property that has both a get accessor and a set accessor is a <em>read-write
                            property</em>, a property that has only a get accessor is a <em>read-only property</em>, and
                        a property that has only a set accessor is a <em>write-only property</em>.
                    </p>
                    <p>
                        A get accessor corresponds to a parameterless method with a return value of the property type. A
                        set accessor corresponds to a method with a single parameter named value and no return type. The
                        get accessor computes the value of the property. The set accessor provides a new value for the
                        property. When the property is the target of an assignment, or the operand of <code>++</code> or
                        <code>--</code>, the set accessor is invoked. In other cases where the property is referenced,
                        the get accessor is invoked.
                    </p>
                    <p>
                        When a property is referenced as the target of an assignment or as the operand of ++ or --, the
                        set accessor is invoked with an argument that provides the new value.
                    </p>
                    <p>
                        The <code>MyList&lt;T&gt;</code> class declares two properties, <code>Count</code> and
                        <code>Capacity</code>, which are read-only and read-write, respectively. The following code is
                        an example of use of these properties:
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
MyList&lt;<span class="code-keyword">string</span>&gt; names = <span class="code-keyword">new</span> MyList&lt;<span class="code-keyword">string</span>&gt;();
names.Capacity = 100;     <span class="code-comment">// Invokes set accessor</span>
<span class="code-keyword">int</span> i = names.Count;      <span class="code-comment">// Invokes get accessor</span>
<span class="code-keyword">int</span> j = names.Capacity;   <span class="code-comment">// Invokes get accessor</span>
                            </code>
                        </pre>
                    </div>
                    <p>
                        Similar to fields and methods, C# supports both instance properties and static properties.
                        Static properties are declared with the static modifier, and instance properties are declared
                        without it.
                    </p>
                    <p>
                        The accessor(s) of a property can be virtual. When a property declaration includes a
                        <code>virtual</code>, <code>abstract</code>, or <code>override</code> modifier, it applies to
                        the accessor(s) of the property.
                    </p>
                </article>
            </section>

            <section id="indexers">
                <header>
                    <h3>Indexers</h3>
                </header>
                <article>
                    <p>
                        An <em>indexer</em> is a member that enables objects to be indexed in the same way as an array.
                        An indexer is declared like a property except that the name of the member is <code>this</code>
                        followed by a parameter list written between the delimiters <code>[</code> and <code>]</code>.
                        The parameters are available in the accessor(s) of the indexer. Similar to properties, indexers
                        can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.
                    </p>
                    <p>
                        The <code>MyList&lt;T&gt;</code> class declares a single read-write indexer that takes an
                        <code>int</code> parameter. The indexer makes it possible to index <code>MyList&lt;T&gt;</code>
                        instances with <code>int</code> values. For example:
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
MyList&lt;<span class="code-keyword">string</span>&gt; names = <span class="code-keyword">new</span> MyList&lt;<span class="code-keyword">string</span>&gt;();
names.Add(<span class="code-string">"Liz"</span>);
names.Add(<span class="code-string">"Martha"</span>);
names.Add(<span class="code-string">"Beth"</span>);
<span class="code-keyword">for</span> (<span class="code-keyword">int</span> i = 0; i &lt; names.Count; i++)
{
    <span class="code-keyword">string</span> s = names[i];
    names[i] = s.ToUpper();
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        Indexers can be overloaded. A class can declare multiple indexers as long as the number or types
                        of their parameters differ.
                    </p>
                </article>
            </section>

            <section id="events">
                <header>
                    <h3>Events</h3>
                </header>
                <article>
                    <p>
                        An <em>event</em> is a member that enables a class or object to provide notifications. An event
                        is declared like a field except that the declaration includes an <code>event</code> keyword and
                        the type must be a delegate type.
                    </p>
                    <p>
                        Within a class that declares an event member, the event behaves just like a field of a delegate
                        type (provided the event isn't abstract and doesn't declare accessors). The field stores a
                        reference to a delegate that represents the event handlers that have been added to the event. If
                        no event handlers are present, the field is <code>null</code>.
                    </p>
                    <p>
                        The <code>MyList&lt;T&gt;</code> class declares a single event member called
                        <code>Changed</code>, which indicates that a new item has been added to the list. The Changed
                        event is raised by the <code>OnChanged</code> virtual method, which first checks whether the
                        event is <code>null</code> (meaning that no handlers are present). The notion of raising an
                        event is precisely equivalent to invoking the delegate represented by the event. There are no
                        special language constructs for raising events.
                    </p>
                    <p>
                        Clients react to events through <em>event handlers</em>. Event handlers are attached using the
                        <code>+=</code> operator and removed using the <code>-=</code> operator. The following example
                        attaches an event handler to the <code>Changed</code> event of a
                        <code>MyList&lt;string&gt;</code>.
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">class</span> <span class="code-title">EventExample</span>
{
    <span class="code-keyword">static int</span> s_changeCount;

    <span class="code-keyword">static void</span> <span class="code-title">ListChanged</span>(<span class="code-keyword">object</span> sender, EventArgs e)
    {
        s_changeCount++;
    }

    <span class="code-keyword">public static void</span> <span class="code-title">Usages</span>()
    {
        <span class="code-keyword">var</span> names = <span class="code-keyword">new</span> MyList&lt;<span class="code-keyword">string</span>&gt;();
        names.Changed += <span class="code-keyword">new</span> EventHandler(ListChanged);
        names.Add(<span class="code-string">"Liz"</span>);
        names.Add(<span class="code-string">"Martha"</span>);
        names.Add(<span class="code-string">"Beth"</span>);
        Console.WriteLine(s_changeCount);   <span class="code-comment">// "3"</span>
    }
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        For advanced scenarios where control of the underlying storage of an event is desired, an event
                        declaration can explicitly provide <code>add</code> and <code>remove</code> accessors, which are
                        similar to the <code>set</code> accessor of a property.
                    </p>
                </article>
            </section>

            <section id="operators">
                <header>
                    <h3>Operators</h3>
                </header>
                <article>
                    <p>
                        An <em>operator</em> is a member that defines the meaning of applying a particular expression
                        operator to instances of a class. Three kinds of operators can be defined: unary operators,
                        binary operators, and conversion operators. All operators must be declared as
                        <code>public</code> and <code>static</code>.
                    </p>
                    <p>
                        The <code>MyList&lt;T&gt;</code> class declares two operators, <code>operator ==</code> and
                        <code>operator !=</code>. These overridden operators give new meaning to expressions that apply
                        those operators to <code>MyList</code> instances. Specifically, the operators define equality of
                        two <code>MyList&lt;T&gt;</code> instances as comparing each of the contained objects using
                        their <code>Equals</code> methods. The following example uses the <code>==</code> operator to
                        compare two <code>MyList&lt;int&gt;</code> instances.
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
MyList&lt;<span class="code-keyword">int</span>&gt; a = <span class="code-keyword">new</span> MyList&lt;<span class="code-keyword">int</span>&gt;();
a.Add(1);
a.Add(2);
MyList&lt;<span class="code-keyword">int</span>&gt; b = <span class="code-keyword">new</span> MyList&lt;<span class="code-keyword">int</span>&gt;();
b.Add(1);
b.Add(2);
Console.WriteLine(a == b);  <span class="code-comment">// Outputs "True"</span>
b.Add(3);
Console.WriteLine(a == b);  <span class="code-comment">// Outputs "False"</span>
                            </code>
                        </pre>
                    </div>
                    <p>
                        The first <code>Console.WriteLine</code> outputs <code>True</code> because the two lists contain
                        the same number of objects with the same values in the same order. Had
                        <code>MyList&lt;T&gt;</code> not defined <code>operator ==</code>, the first
                        <code>Console.WriteLine</code> would have output <code>False</code> because <code>a</code> and
                        <code>b</code> reference different <code>MyList&lt;int&gt;</code> instances.
                    </p>
                </article>
            </section>

            <section id="finalizers">
                <header>
                    <h3>Finalizers</h3>
                </header>
                <article>
                    <p>
                        A <em>finalizer</em> is a member that implements the actions required to finalize an instance of
                        a class. Typically, a finalizer is needed to release unmanaged resources. Finalizers can't have
                        parameters, they can't have accessibility modifiers, and they can't be invoked explicitly. The
                        finalizer for an instance is invoked automatically during garbage collection. For more details,
                        see the article on <a
                            href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/destructors">finalizers</a>.
                    </p>
                    <p>
                        The garbage collector is allowed wide latitude in deciding when to collect objects and run
                        finalizers. Specifically, the timing of finalizer invocations isn't deterministic, and
                        finalizers may be executed on any thread. For these and other reasons, classes should implement
                        finalizers only when no other solutions are feasible.
                    </p>
                    <p>
                        The <code>using</code> statement provides a better approach to object destruction.
                    </p>
                </article>
            </section>

            <section id="expressions">
                <header>
                    <h3>Expressions</h3>
                </header>
                <article>
                    <p>
                        <em>Expressions</em> are constructed from <em>operands</em> and <em>operators</em>. The
                        operators of an expression indicate which operations to apply to the operands. Examples of
                        operators include <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, and
                        <code>new</code>. Examples of operands include literals, fields, local variables, and
                        expressions.
                    </p>
                    <p>
                        When an expression contains multiple operators, the <em>precedence</em> of the operators
                        controls the order in which the individual operators are evaluated. For example, the expression
                        <code>x + y * z</code> is evaluated as <code>x + (y * z)</code> because the <code>*</code>
                        operator has higher precedence than the <code>+</code> operator.
                    </p>
                    <p>
                        When an operand occurs between two operators with the same precedence, the
                        <em>associativity</em> of the operators controls the order in which the operations are
                        performed:
                    </p>
                    <ul>
                        <li>Except for the assignment and null-coalescing operators, all binary operators are
                            <em>left-associative</em>, meaning that operations are performed from left to right. For
                            example, <code>x + y + z</code> is evaluated as <code>(x + y) + z</code>.</li>
                        <li>The assignment operators, the null-coalescing <code>??</code> and <code>??=</code>
                            operators, and the conditional operator <code>?:</code> are <em>right-associative</em>,
                            meaning that operations are performed from right to left. For example,
                            <code>x = y = z</code> is evaluated as <code>x = (y = z)</code>.</li>
                    </ul>
                    <p>
                        Precedence and associativity can be controlled using parentheses. For example,
                        <code>x + y * z</code> first multiplies <code>y</code> by <code>z</code> and then adds the
                        result to <code>x</code>, but <code>(x + y) * z</code> first adds <code>x</code> and
                        <code>y</code> and then multiplies the result by <code>z</code>.
                    </p>
                    <p>
                        Most operators can be <em><a
                                href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/operator-overloading">overloaded</a></em>.
                        Operator overloading permits user-defined operator implementations to be specified for
                        operations where one or both of the operands are of a user-defined class or struct type.
                    </p>
                    <p>
                        C# provides a number of operators to perform <a
                            href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/arithmetic-operators">arithmetic</a>,
                        <a
                            href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/boolean-logical-operators">logical</a>,
                        <a
                            href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators">bitwise
                            and shift</a> operations and <a
                            href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/equality-operators">equality</a>
                        and <a
                            href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/comparison-operators">order</a>
                        comparisons.
                    </p>
                    <p>
                        For the complete list of C# operators ordered by precedence level, see <a
                            href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/">C#
                            operators</a>.
                    </p>
                </article>
            </section>

            <section id="statements">
                <header>
                    <h3>Statements</h3>
                </header>
                <article>
                    <p>
                        The actions of a program are expressed using statements. C# supports several different kinds of
                        statements, a number of which are defined in terms of embedded statements.
                    </p>
                    <ul>
                        <li>A <em>block</em> permits multiple statements to be written in contexts where a single
                            statement is allowed. A block consists of a list of statements written between the
                            delimiters <code>{</code> and <code>}</code>.</li>
                        <li><em>Declaration statements</em> are used to declare local variables and constants.</li>
                        <li><em>Expression statements</em> are used to evaluate expressions. Expressions that can be
                            used as statements include method invocations, object allocations using the <code>new</code>
                            operator, assignments using <code>=</code> and the compound assignment operators, increment
                            and decrement operations using the <code>++</code> and <code>--</code> operators and
                            <code>await</code> expressions.</li>
                        <li><em>Selection statements</em> are used to select one of a number of possible statements for
                            execution based on the value of some expression. This group contains the <code>if</code> and
                            <code>switch</code> statements.</li>
                        <li><em>Iteration statements</em> are used to execute repeatedly an embedded statement. This
                            group contains the <code>while</code>, <code>do</code>, <code>for</code>, and
                            <code>foreach</code> statements.</li>
                        <li><em>Jump statements</em> are used to transfer control. This group contains the
                            <code>break</code>, <code>continue</code>, <code>goto</code>, <code>throw</code>,
                            <code>return</code>, and <code>yield</code> statements.</li>
                        <li>The <code>try</code>...<code>catch</code> statement is used to catch exceptions that occur
                            during execution of a block, and the <code>try</code>...<code>finally</code> statement is
                            used to specify finalization code that is always executed, whether an exception occurred or
                            not.</li>
                        <li>The <code>checked</code> and <code>unchecked</code> statements are used to control the
                            overflow-checking context for integral-type arithmetic operations and conversions.</li>
                        <li>The <code>lock</code> statement is used to obtain the mutual-exclusion lock for a given
                            object, execute a statement, and then release the lock.</li>
                        <li>The <code>using</code> statement is used to obtain a resource, execute a statement, and then
                            dispose of that resource.</li>
                    </ul>
                    <p>
                        The following lists the kinds of statements that can be used:
                    </p>
                    <ul>
                        <li>Local variable declaration.</li>
                        <li>Local constant declaration.</li>
                        <li>Expression statement.</li>
                        <li><code>if</code> statement.</li>
                        <li><code>switch</code> statement.</li>
                        <li><code>while</code> statement.</li>
                        <li><code>do</code> statement.</li>
                        <li><code>for</code> statement.</li>
                        <li><code>foreach</code> statement.</li>
                        <li><code>break</code> statement.</li>
                        <li><code>continue</code> statement.</li>
                        <li><code>goto</code> statement.</li>
                        <li><code>return</code> statement.</li>
                        <li><code>yield</code> statement.</li>
                        <li><code>throw</code> statements and <code>try</code> statements.</li>
                        <li><code>checked</code> and <code>unchecked</code> statements.</li>
                        <li><code>lock</code> statement.</li>
                        <li><code>using</code> statement.</li>
                    </ul>
                </article>
            </section>

        </section>

        <section id="Major_Language_Areas" class="main-section">
            <header>
                <h2>Major Language Areas</h2>
            </header>
            <article></article>

            <section id="arrays-collections-and-linq">
                <header>
                    <h3>Arrays, Collections and LINQ</h3>
                </header>
                <article>
                    <p>
                        C# and .NET provide many different collection types. Arrays have syntax defined by the language.
                        Generic collection types are listed in the <a
                            href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic">System.Collections.Generic</a>
                        namespace. Specialized collections include <a
                            href="https://docs.microsoft.com/en-us/dotnet/api/system.span-1">System.Span&lt;T&gt;</a>
                        for accessing continuous memory on the stack frame, and <a
                            href="https://docs.microsoft.com/en-us/dotnet/api/system.memory-1">System.Memory&lt;T&gt;</a>
                        for accessing continuous memory on the managed heap. All collections, including arrays, <a
                            href="https://docs.microsoft.com/en-us/dotnet/api/system.span-1">Span&lt;T&gt;</a>, and <a
                            href="https://docs.microsoft.com/en-us/dotnet/api/system.memory-1">Memory&lt;T&gt;</a> share
                        a unifying principle for iteration. You use the <a
                            href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1">System.Collections.Generic.IEnumerable&lt;T&gt;</a>
                        interface. This unifying principle means that any of the collection types can be used with LINQ
                        queries or other algorithms. You write methods using <a
                            href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1">IEnumerable&lt;T&gt;</a>
                        and those algorithms work with any collection.
                    </p>
                </article>
            </section>

            <section id="arrays">
                <header>
                    <h3>Arrays</h3>
                </header>
                <article>
                    <p>
                        An <a
                            href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/"><em><strong>array</strong></em></a>
                        is a data structure that contains a number of variables that are accessed through computed
                        indices. The variables contained in an array, also called the <em><strong>elements</strong></em>
                        of the array, are all of the same type. This type is called the <em><strong>element
                                type</strong></em> of the array.
                    </p>
                    <p>
                        Array types are reference types, and the declaration of an array variable simply sets aside
                        space for a reference to an array instance. Actual array instances are created dynamically at
                        runtime using the <code>new</code> operator. The <code>new</code> operation specifies the
                        <em><strong>length</strong></em> of the new array instance, which is then fixed for the lifetime
                        of the instance. The indices of the elements of an array range from <code>0</code> to
                        <code>Length - 1</code>. The <code>new</code> operator automatically initializes the elements of
                        an array to their default value, which, for example, is zero for all numeric types and
                        <code>null</code> for all reference types.
                    </p>
                    <p>
                        The following example creates an array of <code>int</code> elements, initializes the array, and
                        prints out the contents of the array.
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">int</span>[] a = <span class="code-keyword">new int</span>[10];
<span class="code-keyword">for</span> (<span class="code-keyword">int</span> i = 0; i &lt; a.Length; i++)
{
    a[i] = i * i;
}
<span class="code-keyword">for</span> (<span class="code-keyword">int</span> i = 0; i &lt; a.Length; i++)
{
    Console.WriteLine(<span class="code-string">$"a[</span>{i}<span class="code-string">] = </span>{a[i]}<span class="code-string">"</span>);
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        This example creates and operates on a <em><strong>single-dimensional array</strong></em>. C#
                        also supports <em><strong>multi-dimensional arrays</strong></em>. The number of dimensions of an
                        array type, also known as the <em><strong>rank</strong></em> of the array type, is one plus the
                        number of commas written between the square brackets of the array type. The following example
                        allocates a single-dimensional, a two-dimensional, and a three-dimensional array, respectively.
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">int</span>[] a1 = <span class="code-keyword">new int</span>[10];
<span class="code-keyword">int</span>[,] a2 = <span class="code-keyword">new int</span>[10, 5];
<span class="code-keyword">int</span>[,,] a3 = <span class="code-keyword">new int</span>[10, 5, 2];
                            </code>
                        </pre>
                    </div>
                    <p>
                        The <code>a1</code> array contains 10 elements, the <code>a2</code> array contains 50 (10 × 5)
                        elements, and the <code>a3</code> array contains 100 (10 × 5 × 2) elements. The element type of
                        an array can be any type, including an array type. An array with elements of an array type is
                        sometimes called a <em><strong>jagged array</strong></em> because the lengths of the element
                        arrays don't all have to be the same. The following example allocates an array of arrays of
                        <code>int</code>:
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">int</span>[][] a = <span class="code-keyword">new int</span>[3][];
a[0] = <span class="code-keyword">new int</span>[10];
a[1] = <span class="code-keyword">new int</span>[5];
a[2] = <span class="code-keyword">new int</span>[20];
                            </code>
                        </pre>
                    </div>
                    <p>
                        The first line creates an array with three elements, each of type <code>int[]</code> and each
                        with an initial value of <code>null</code>. The next lines then initialize the three elements
                        with references to individual array instances of varying lengths.
                    </p>
                    <p>
                        The <code>new</code> operator permits the initial values of the array elements to be specified
                        using an <em><strong>array initializer</strong></em>, which is a list of expressions written
                        between the delimiters <code>{</code> and <code>}</code>. The following example allocates and
                        initializes an <code>int[]</code> with three elements.
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">int</span>[] a = <span class="code-keyword">new int</span>[] {1, 2, 3 };
                            </code>
                        </pre>
                    </div>
                    <p>
                        The length of the array is inferred from the number of expressions between <code>{</code> and
                        <code>}</code>. Local variable and field declarations can be shortened further such that the
                        array type doesn't have to be restated.
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">int</span>[] a = {1, 2, 3 };
                            </code>
                        </pre>
                    </div>
                    <p>
                        Both of the previous examples are equivalent to the following code:
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">int</span>[] t = <span class="code-keyword">new int</span>[3];
t[0] = 1;
t[1] = 2;
t[2] = 3
<span class="code-keyword">int</span>[] a = t;
                            </code>
                        </pre>
                    </div>
                    <p>
                        The <code>foreach</code> statement can be used to enumerate the elements of any collection. The
                        following code enumerates the array from the preceding example:
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">foreach</span> (<span class="code-keyword">int</span> item <span class="code-keyword">in</span> a)
{
    Console.WriteLine(item);
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        The <code>foreach</code> statement uses the <a
                            href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1">IEnumerable&lt;T&gt;</a>
                        interface, so can work with any collection.
                    </p>
                </article>
            </section>

            <section id="string-interpolation">
                <header>
                    <h3>String Interpolation</h3>
                </header>
                <article>
                    <p>
                        C# <a
                            href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated"><em><strong>string
                                    interpolation</strong></em></a> enables you to format strings by defining
                        expressions whose results are placed in a format string. For example, the following example
                        prints the temperature on a given day from a set of weather data:
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
Console.WriteLine(<span class="code-string">$"The low and high temperature on</span> {weatherData.Date:MM-DD-YYYY}<span class="code-string">"</span>);
Console.WriteLine(<span class="code-string">$"    was</span> {weatherData.LowTemp} <span class="code-string">and</span> {weatherData.HighTemp}<span class="code-string">."</span>);
<span class="code-comment">// Output (similar to):</span>
<span class="code-comment">// The low and high temperature on 08-11-2020</span>
<span class="code-comment">//     was 5 and 30</span>
                            </code>
                        </pre>
                    </div>
                    <p>
                        An interpolated string is declared using the <code>$</code> token. String interpolation
                        evaluates the expressions between <code>{</code> and <code>}</code>, then converts the result to
                        a <code>string</code>, and replaces the text between the brackets with the string result of the
                        expression. The <code>:</code> in the first expression,
                        <code>{weatherData.Data:MM-DD-YYYY}</code> specifies the <em>format string</em>. In the
                        preceding example, it specifies that the date should be printed in "MM-DD-YYYY" format.
                    </p>
                </article>
            </section>

            <section id="pattern-matching">
                <header>
                    <h3>Pattern Matching</h3>
                </header>
                <article>
                    <p>
                        The C# language provides <a
                            href="https://docs.microsoft.com/en-us/dotnet/csharp/pattern-matching"><em><strong>pattern
                                    matching</strong></em></a> expressions to query the state of an object and execute
                        code based on that state. You can inspect types and the values of properties and fields to
                        determine which action to take. The <code>switch</code> expression is the primary expression for
                        pattern matching.
                    </p>
                </article>
            </section>

            <section id="delegates-and-llambda-expressions">
                <header>
                    <h3>Delegates and Llambda Expressions</h3>
                </header>
                <article>
                    <p>
                        A <a href="https://docs.microsoft.com/en-us/dotnet/csharp/delegates-overview"><em><strong>delegate
                                    type</strong></em></a> represents references to methods with a particular parameter
                        list and return type. Delegates make it possible to treat methods as entities that can be
                        assigned to variables and passed as parameters. Delegates are similar to the concept of function
                        pointers found in some other languages. Unlike function pointers, delegates are object-oriented
                        and type-safe.
                    </p>
                    <p>
                        The following example declares and uses a delegate type named <code>Function</code>.
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">delegate double</span> <span class="code-title">Function</span>(<span class="code-keyword">double</span> x);

<span class="code-keyword">class</span> <span class="code-title">Multiplier</span>
{
    <span class="code-keyword">double</span> _factor;

    <span class="code-keyword">public</span> <span class="code-title">Multiplier</span>(<span class="code-keyword">double</span> factor) => _factor = factor;

    <span class="code-keyword">public double</span> <span class="code-title">Multiply</span>(<span class="code-keyword">double</span> x) => x * _factor;
}

<span class="code-keyword">class</span> <span class="code-title">DelegateExample</span>
{
    <span class="code-keyword">static double</span>[] <span class="code-title">Apply</span>(<span class="code-keyword">double</span>[] a, Function f)
    {
        <span class="code-keyword">var</span> result = <span class="code-keyword">new double</span>[a.Length];
        <span class="code-keyword">for (<span class="code-keyword">int</span> i = 0; i &lt; a.Length; i++) result[i] = f(a[i]);
        <span class="code-keyword">return</span> result;
    }

    <span class="code-keyword">public static void</span> <span class="code-title">Main</span>()
    {
        <span class="code-keyword">double</span>[] a = { 0.0, 0.5, 1.0 };
        <span class="code-keyword">double</span> sqaures = Apply(a, (x) => x * x);
        <span class="code-keyword">double</span> sines = Apply(a, Math.Sin);
        Multiplier m = <span class="code-keyword">new</span> Multiplier(2.0);
        <span class="code-keyword">double</span>[] doubles = Apply(a, m.Multiply);
    }
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        An instance of the <code>Function</code> delegate type can reference any method that takes a
                        <code>double</code> argument and returns a <code>double</code> value. The <code>Apply</code>
                        method applies a given <code>Function</code> to the elements of a <code>double[]</code>,
                        returning a <code>double[]</code> with the results. In the <code>Main</code> method,
                        <code>Apply</code> is used to apply three different functions to a <code>double[]</code>.
                    </p>
                    <p>
                        A delegate can reference either a static method (such as <code>Square</code> or
                        <code>Math.Sin</code> in the previous example) or an instance method (such as
                        <code>m.Multiply</code> in the previous example). A delegate that references an instance method
                        also references a particular object, and when the instance method is invoked through the
                        delegate, that object becomes <code>this</code> in the invocation.
                    </p>
                    <p>
                        Delegates can also be created using anonymous functions, which are "inline methods" that are
                        created when declared. Anonymous functions can see the local variables of the surrounding
                        methods. The following example doesn't create a class:
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">double</span>[] doubles = Apply(a, (<span class="code-keyword">double</span> x) => x * 2.0);
                            </code>
                        </pre>
                    </div>
                    <p>
                        A delegate doesn't know or care about the class of the method it references. All that matters is
                        that the referenced method has the same parameters and return type as the delegate.
                    </p>
                </article>
            </section>

            <section id="async-await">
                <header>
                    <h3>Async / Await</h3>
                </header>
                <article>
                    <p>
                        C# supports asynchronous programs with two keywords: <code>async</code> and <code>await</code>.
                        You add the <code>async</code> modifier to a method declaration to declare the method is
                        asynchronous. The <code>await</code> operator tells the compiler to asynchronously await for a
                        result to finish. Control is returned to the caller, and the method returns a structure that
                        manages the state of the asynchronous work. The structure is typically a <a
                            href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task-1">System.Threading.Tasks.Task&lt;TResult&gt;</a>,
                        but can be any type that supports the awaiter pattern. These features enable you to write code
                        that reads as its synchronous counterpart, but executes asynchronously. For example, the
                        following code downloads the home page for <a href="https://docs.microsoft.com/en-us/">Microsoft
                            docs</a>:
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">public async</span> Task&lt;<span class="code-keyword">int</span>&gt; <span class="code-title">RetrieveDocsHomePage</span>()
{
    <span class="code-keyword">var</span> client = <span class="code-keyword">new</span> HttpClient();
    <span class="code-keyword">byte</span>[] content = <span class="code-keyword">await</span> client.GetByteArrayAsync(<span class="code-string">"https://docs.microsoft.com/"</span>);

    Console.WriteLine(<span class="code-string">$"</span>{<span class="code-keyword">nameof</span>(RetrieveDocsHomePage)}<span class="code-string">: Finished downloading."</span>);
    <span class="code-keyword">return</span> content.Length;
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        This small sample shows the major features for asynchronous programming:
                    </p>
                    <ul>
                        <li>The method declaration includes the <code>async</code> modifier.</li>
                        <li>The body of the method <code>await</code>s the return of the <code>GetByteArrayAsync</code>
                            method.</li>
                        <li>The type specified in the <code>return</code> statement matches the type argument in the
                            <code>Task&lt;T&gt;</code> declaration for the method. (A method that returns a
                            <code>Task</code> would use <code>return</code> statements without any argument).</li>
                    </ul>
                </article>
            </section>

            <section id="attributes">
                <header>
                    <h3>Attributes</h3>
                </header>
                <article>
                    <p>
                        Types, members, and other entities in a C# program support modifiers that control certain
                        aspects of their behavior. For example, the accessibility of a method is controlled using the
                        <code>public</code>, <code>protected</code>, <code>internal</code>, and <code>private</code>
                        modifiers. C# generalizes this capability such that user-defined types of declarative
                        information can be attached to program entities and retrieved at run-time. Programs specify this
                        additional declarative information by defining and using <a
                            href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/"><em><strong>attributes</strong></em></a>.
                    </p>
                    <p>
                        The following example declares a <code>HelpAttribute</code> attribute that can be placed on
                        program entities to provide links to their associated documentation.
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
<span class="code-keyword">public class</span> <span class="code-title">HelpAttribute</span> : <span class="code-title">Attribute</span>
{
    <span class="code-keyword">string</span> _url;
    <span class="code-keyword">string</span> _topic;

    <span class="code-keyword">public</span> <span class="code-title">HelpAttribute</span>(<span class="code-keyword">string</span> url) => _url = url;

    <span class="code-keyword">public string</span> Url => _url;

    <span class="code-keyword">public string</span> Topic
    {
        <span class="code-keyword">get</span> => _topic;
        <span class="code-keyword">set</span> => _topic = <span class="code-keyword">value</span>;
    }
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        All attribute classes derive from the <a
                            href="https://docs.microsoft.com/en-us/dotnet/api/system.attribute">Attribute</a> base class
                        provided by the .NET library. Attributes can be applied by giving their name, along with any
                        arguments, inside square brackets just before the associated declaration. If an attribute’s name
                        ends in <code>Attribute</code>, that part of the name can be omitted when the attribute is
                        referenced. For example, the <code>HelpAttribute</code> can be used as follows.
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
[<span class="code-title">Help</span>(<span class="code-string">"https://docs.microsoft.com/dotnet/csharp/tour-of-csharp/features"</span>)]
<span class="code-keyword">public class</span> <span class="code-title">Widget</span>
{
    [<span class="code-title">Help</span>(<span class="code-string">"https://docs.microsoft.com/dotnet/csharp/tour-of-csharp/features"</span>,
    <span class="code-title">Topic</span> = <span class="code-string">"Display"</span>)]
    <span class="code-keyword">public void</span> <span class="code-title">Display</span>(<span class="code-keyword">string</span> text) { }
}
                            </code>
                        </pre>
                    </div>
                    <p>
                        This example attaches a <code>HelpAttribute</code> to the <code>Widget</code> class. It adds
                        another <code>HelpAttribute</code> to the <code>Display</code> method in the class. The public
                        constructors of an attribute class control the information that must be provided when the
                        attribute is attached to a program entity. Additional information can be provided by referencing
                        public read-write properties of the attribute class (such as the reference to the
                        <code>Topic</code> property previously).
                    </p>
                    <p>
                        The metadata defined by attributes can be read and manipulated at runtime using reflection. When
                        a particular attribute is requested using this technique, the constructor for the attribute
                        class is invoked with the information provided in the program source, and the resulting
                        attribute instance is returned. If additional information was provided through properties, those
                        properties are set to the given values before the attribute instance is returned.
                    </p>
                    <p>
                        The following code sample demonstrates how to get the <code>HelpAttribute</code> instances
                        associated to the <code>Widget</code> class and its <code>Display</code> method.
                    </p>
                    <div class="code-block">
                        <pre>
                            <code>
Type widgetType = <span class="code-keyword">typeof</span>(Widget);

<span class="code-keyword">object</span>[] widgetClassAttributes = widgetType.GetCustomAttributes(<span class="code-keyword">typeof</span>(HelpAttribute), <span class="code-title">false</span>);

<span class="code-keyword">if</span> (widgetClassAttributes.Length &gt; 0)
{
    HelpAttribute attr = (HelpAttribute)widgetClassAttributes[0];
    Console.WriteLine(<span class="code-string">$"Widget class help URL :</span> {attr.URL} <span class="code-string">- Related topic :</span> {attr.Topic}<span class="code-string">"</span>);
}

System.Reflection.MethodInfo displayMethod = widgetType.GetMethod(<span class="code-keyword">nameof</span>(Widget.Display));

<span class="code-keyword">object</span>[] displayMethodAttributes = displayMethod.GetCustomAttributes(<span class="code-keyword">typeof</span>(HelpAttribute), <span class="code-title">false</span>);

<span class="code-keyword">if</span> (displayMethodAttributes.Length &gt; 0)
{
    HelpAttribute attr = (HelpAttribute)displayMethodAttributes[0];
    Console.WriteLine(<span class="code-string">$"Display method help URL :</span> {attr.URL} <span class="code-string">- Related topic :</span> {attr.Topic}<span class="code-string">"</span>);
}
                            </code>
                        </pre>
                    </div>
                </article>
            </section>

        </section>

        <section id="Conclusion" class="main-section"> 
            <header>
                <h2>Conclusion</h2>
            </header>
        </section>
            

    </main>

    <footer>

    </footer>

    <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
    <script src="./JS/index.js"></script>

</body>